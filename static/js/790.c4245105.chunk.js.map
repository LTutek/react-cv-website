{"version":3,"file":"static/js/790.c4245105.chunk.js","mappings":"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","sources":["../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/core/helpers/immutability-helpers.ts","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout-store.ts","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout.scss?tag=sdx-menu-flyout&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout-content/menu-flyout-content.scss?tag=sdx-menu-flyout-content&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout-content/menu-flyout-content.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout-list/menu-flyout-list.scss?tag=sdx-menu-flyout-list&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout-list/menu-flyout-list.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout-list/menu-flyout-list-item/menu-flyout-list-item.scss?tag=sdx-menu-flyout-list-item&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout-list/menu-flyout-list-item/menu-flyout-list-item.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout-toggle/menu-flyout-toggle.scss?tag=sdx-menu-flyout-toggle&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/menu-flyout/menu-flyout-toggle/menu-flyout-toggle.tsx","../node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js"],"sourcesContent":["/**\n * Adds an item to a list, if it does not exist, yet.\n * @param list The array that might contain the given item.\n * @param item The element that should be added.\n */\nexport function add<I>(list: I[], item: I): I[] {\n  if (!list.includes(item)) {\n    return [...list, item]\n  }\n\n  return list\n}\n\n/**\n * Removes an item from a list, if it exists.\n * @param list The array that might contain the given item.\n * @param item The element that should be removed.\n */\nexport function remove<I>(list: I[], item: I): I[] {\n  if (list.includes(item)) {\n    return list.filter((currentItem) => currentItem !== item)\n  }\n\n  return list\n}\n\n/**\n * Adds an item to a list, if it does not exist, yet.\n * If it does exist, however, it removes it.\n * @param list The array that might contain the given item.\n * @param item The element that should be added or removed.\n */\nexport function toggle<I>(list: I[], item: I): I[] {\n  if (!list.includes(item)) {\n    return add(list, item)\n  }\n\n  return remove(list, item)\n}\n\n/**\n * Like Array map() but for objects.\n * Example: { foo: \"bar\" } => { foo1: \"bar1\" }\n * @param obj Object to iterate.\n * @param cb Callback that transforms key and value.\n */\nexport function objectMap(\n  obj: Record<string, unknown> | undefined,\n  cb: (key: string, value: unknown) => Record<string, unknown>\n): Record<string, unknown> {\n  let newObj: Record<string, unknown> = {}\n\n  for (const key in obj) {\n    newObj = { ...newObj, ...cb(key, obj[key]) }\n  }\n\n  return newObj\n}\n","import { Reducer } from \"redux\"\nimport { Direction } from \"./types\"\nimport { Display } from \"../../core/types/types\"\nimport { add, remove } from \"../../core/helpers/immutability-helpers\"\n\nexport interface MenuFlyoutState {\n  display: Display\n  direction: Direction\n  toggle: () => Promise<void>\n  arrowEls: HTMLElement[]\n  userInteractionInProgress: boolean\n  contentEl?: HTMLSdxMenuFlyoutListElement | HTMLSdxMenuFlyoutCtaElement\n  toggleEl?: HTMLSdxMenuFlyoutToggleElement\n}\n\nexport type MenuFlyoutActions =\n  | {\n      type: \"ADD_ARROW_EL\"\n      arrowEl: HTMLElement\n    }\n  | {\n      type: \"REMOVE_ARROW_EL\"\n      arrowEl: HTMLElement\n    }\n\nexport const menuFlyoutReducer: Reducer<MenuFlyoutState, MenuFlyoutActions> = (\n  state = {} as MenuFlyoutState,\n  action\n): MenuFlyoutState => {\n  switch (action.type) {\n    case \"ADD_ARROW_EL\":\n      return {\n        ...state,\n        arrowEls: add(state.arrowEls, action.arrowEl),\n      }\n\n    case \"REMOVE_ARROW_EL\":\n      return {\n        ...state,\n        arrowEls: remove(state.arrowEls, action.arrowEl),\n      }\n\n    default:\n      return state\n  }\n}\n\nexport function getInitialState(): MenuFlyoutState {\n  return {\n    display: \"closed\",\n    direction: \"bottom-right\",\n    toggle: () => Promise.resolve(),\n    contentEl: undefined,\n    userInteractionInProgress: false,\n    toggleEl: undefined,\n    arrowEls: [],\n  }\n}\n","import {\n  Component,\n  h,\n  Element,\n  Prop,\n  State,\n  Listen,\n  Method,\n  Event,\n  EventEmitter,\n  Watch,\n} from \"@stencil/core\"\nimport anime from \"animejs\"\nimport {\n  menuFlyoutReducer,\n  getInitialState,\n  MenuFlyoutState,\n  MenuFlyoutActions,\n} from \"./menu-flyout-store\"\nimport {\n  StoreConnection,\n  StateHandle,\n  parseFunction,\n  getOverlayOutletEl,\n  getScrollContainerEl,\n  getScreenOrientationAngle,\n  appendToOverlayOutlet,\n  getScrollTopLeft,\n} from \"../../core/helpers/webcomponent-helpers\"\nimport { Display } from \"../../core/types/types\"\nimport { Direction } from \"./types\"\n\n@Component({\n  tag: \"sdx-menu-flyout\",\n  styleUrl: \"menu-flyout.scss\",\n  shadow: true,\n})\nexport class MenuFlyout {\n  private store: StoreConnection<this, MenuFlyoutState, MenuFlyoutActions>\n  private isConnected = false\n  private invokeDisplayChangeCallback: Function = () => null\n  private overlayOutletEl?: Element\n  private scrollContainerEl?: Element\n  private animationDuration = 300\n\n  private oppositeDirection: {\n    x: { [key in Direction]: Direction }\n    y: { [key in Direction]: Direction }\n  } = {\n    x: {\n      \"top-right\": \"top-left\",\n      \"top-left\": \"top-right\",\n      \"bottom-right\": \"bottom-left\",\n      \"bottom-left\": \"bottom-right\",\n    },\n    y: {\n      \"top-right\": \"bottom-right\",\n      \"top-left\": \"bottom-left\",\n      \"bottom-right\": \"top-right\",\n      \"bottom-left\": \"top-left\",\n    },\n  }\n\n  /**\n   * The arrow is basically a 14px square (rotated by 45°).\n   */\n  private arrowUnrotatedWidth = 14\n\n  /**\n   * Horizontal distance between contentEl and arrowEl.\n   */\n  private offsetX = 24\n\n  /**\n   * Vertical distance between toggleEl and arrowEl (and, on mobiles, to the\n   * screen).\n   */\n  private offsetY = 16\n\n  private static readonly minSpaceToWindow = 24 // $baseline-3\n  private lastScreenOrientationAngle = 0\n\n  @Element() public el!: HTMLSdxMenuFlyoutElement\n\n  @State() public state!: StateHandle<MenuFlyoutState>\n\n  /**\n   * In which direction the flyout opens. This is probably only needed in rare\n   * cases, because the flyout will automatically open itself towards the\n   * opposite direction if there's not enough space.\n   */\n  @Prop() public direction: Direction = \"bottom-right\"\n\n  /**\n   * Close if the user clicks on the flyout.\n   */\n  @Prop() public closeOnClick: boolean = false\n\n  /**\n   * Callback that will fire after the flyouts display status has changed.\n   * @deprecated use sdxdisplaychange event instead.\n   */\n  @Prop() public displayChangeCallback?: ((display: Display) => void) | string\n\n  /**\n   * Disable animations for testing.\n   * @private\n   */\n  @Prop() public animated: boolean = true\n\n  /**\n   * Emitted when the component's visibility updates.\n   */\n  @Event() public sdxdisplaychange!: EventEmitter<{ display: Display }>\n\n  @Watch(\"state\")\n  public stateChanged({}, prev: StateHandle<MenuFlyoutState>) {\n    const state = this.state.get()\n    const prevState = prev.get()\n\n    if (state.display !== prevState.display) {\n      this.displayChanged(state)\n    }\n\n    if (state.arrowEls !== prevState.arrowEls) {\n      this.arrowElsChanged()\n    }\n  }\n\n  @Watch(\"direction\")\n  public directionChanged() {\n    const { display } = this.state.get()\n\n    if (display !== \"closed\") {\n      // If the flyout is open, re-open it with new direction\n      this.close().then(() => {\n        this.store.set(\"direction\", this.direction)\n        this.open()\n      })\n    } else {\n      this.store.set(\"direction\", this.direction)\n    }\n  }\n\n  @Watch(\"displayChangeCallback\")\n  public displayChangeCallbackChanged() {\n    this.setInvokeDisplayChangeCallback()\n  }\n\n  @Listen(\"resize\", { target: \"window\" })\n  public onWindowResize() {\n    const { display, direction } = this.state.get()\n\n    if (display === \"closed\") {\n      return\n    }\n\n    const currentAngle = getScreenOrientationAngle()\n\n    if (currentAngle !== this.lastScreenOrientationAngle) {\n      // just close in case of an orientation change\n      this.lastScreenOrientationAngle = currentAngle\n      this.close()\n    } else {\n      // in case of a desktop browser resize just recalculate the position\n      this.positionContentEl(direction)\n    }\n  }\n\n  /**\n   * Toggles the flyout.\n   */\n  @Method()\n  public toggle(): Promise<void> {\n    const { display } = this.state.get()\n\n    if (display === \"open\") {\n      return this.close()\n    } else if (display === \"closed\") {\n      return this.open()\n    } else {\n      // Ignore \"opening\" and \"closing\"\n    }\n\n    return Promise.resolve()\n  }\n\n  /**\n   * Opens the flyout.\n   */\n  @Method()\n  public open(): Promise<void> {\n    return new Promise((resolve) => {\n      const { display, direction, contentEl, userInteractionInProgress } =\n        this.state.get()\n\n      if (!contentEl) {\n        return\n      }\n\n      // Only a closed flyout can be opened\n      if (!(display === \"closed\" || display === \"closing\")) {\n        resolve()\n        return\n      }\n\n      this.overlayOutletEl = getOverlayOutletEl()\n      this.scrollContainerEl = getScrollContainerEl(this.el)\n\n      // Check if the flyout is inside a scrollable element.\n      // If yes, append the list there to make sure it scrolls and isn't\n      // detached from the toggle.\n      if (this.scrollContainerEl) {\n        this.overlayOutletEl = this.scrollContainerEl\n      } else {\n        this.scrollContainerEl = document.documentElement\n      }\n\n      // Make contentEl overlap all other content\n      appendToOverlayOutlet(contentEl, this.overlayOutletEl, this.el)\n\n      // Set dimensions\n      contentEl.style.opacity = \"0\"\n      contentEl.style.transform = \"translateY(0)\"\n      this.positionContentEl(direction)\n\n      const offsetY =\n        // Update direction (overwritten above)\n        this.state.get().direction === \"top-left\" ||\n        this.state.get().direction === \"top-right\"\n          ? -this.offsetY\n          : this.offsetY\n\n      this.setDisplay(\"opening\", userInteractionInProgress)\n      anime.remove(contentEl)\n\n      anime({\n        targets: contentEl,\n        duration: this.animated ? this.animationDuration : 0,\n        translateY: offsetY,\n        opacity: 1,\n        easing: \"cubicBezier(0.550, 0.085, 0.320, 1)\",\n        complete: () => {\n          this.setDisplay(\"open\", userInteractionInProgress)\n          resolve()\n        },\n      })\n    })\n  }\n\n  /**\n   * Closes the flyout.\n   */\n  @Method()\n  public close(): Promise<void> {\n    return new Promise((resolve) => {\n      const { display, contentEl, userInteractionInProgress } = this.state.get()\n\n      if (!contentEl) {\n        return\n      }\n\n      // Only an opened flyout can be closed\n      if (display === \"closed\" || display === \"closing\") {\n        resolve()\n        return\n      }\n\n      this.setDisplay(\"closing\", userInteractionInProgress)\n      anime.remove(contentEl)\n\n      anime({\n        targets: contentEl,\n        duration: this.animated ? this.animationDuration : 0,\n        translateY: 0,\n        opacity: 0,\n        easing: \"cubicBezier(0.550, 0.085, 0.320, 1)\",\n        complete: () => {\n          contentEl!.style.display = \"none\"\n\n          // Reset to original direction (it might have changed during opening\n          // because of not enough space)\n          this.store.set(\"direction\", this.direction)\n\n          this.setDisplay(\"closed\", userInteractionInProgress)\n\n          // Move contentEl back\n          appendToOverlayOutlet(contentEl, this.el, this.el)\n\n          resolve()\n        },\n      })\n    })\n  }\n\n  /**\n   * @private\n   * Calls close(), but only when the component is allowed to be closed.\n   */\n  @Method()\n  public async requestToClose(\n    e: KeyboardEvent | MouseEvent | TouchEvent\n  ): Promise<void> {\n    const { contentEl, display } = this.state.get()\n\n    if (!(contentEl && display === \"open\")) {\n      return\n    }\n\n    if (e instanceof KeyboardEvent) {\n      if (e.key === \"Escape\") {\n        this.store.set(\"userInteractionInProgress\", true)\n        this.close()\n        this.store.set(\"userInteractionInProgress\", false)\n      }\n\n      return\n    }\n\n    const didClickOnContentEl = e.composedPath().includes(contentEl)\n\n    if (didClickOnContentEl) {\n      if (this.closeOnClick) {\n        this.store.set(\"userInteractionInProgress\", true)\n        this.close()\n        this.store.set(\"userInteractionInProgress\", false)\n      }\n\n      return\n    }\n\n    // Clicked somewhere else on window\n    this.store.set(\"userInteractionInProgress\", true)\n    this.close()\n    this.store.set(\"userInteractionInProgress\", false)\n  }\n\n  constructor() {\n    this.setInvokeDisplayChangeCallback()\n\n    this.store = new StoreConnection(\n      this,\n      menuFlyoutReducer,\n      getInitialState(),\n      [\"display\", \"direction\", \"contentEl\", \"toggleEl\", \"arrowEls\"]\n    )\n\n    this.store.set(\"direction\", this.direction)\n    this.store.set(\"toggle\", this.toggle.bind(this))\n\n    this.store.flush()\n  }\n\n  public connectedCallback() {\n    this.isConnected = true\n  }\n\n  public disconnectedCallback() {\n    this.isConnected = false\n\n    // Make sure the flyout is closed when removed from the DOM\n    this.close()\n  }\n\n  public componentDidLoad() {\n    this.store.subscribe()\n  }\n\n  private displayChanged(state: MenuFlyoutState) {\n    this.invokeDisplayChangeCallback(state.display)\n  }\n\n  private setDisplay(\n    display: Display,\n    userInteractionInProgress: boolean\n  ): void {\n    this.store.set(\"display\", display)\n\n    // Only fire events on end user interaction\n    if (!userInteractionInProgress) {\n      return\n    }\n\n    this.sdxdisplaychange.emit({ display })\n  }\n\n  private arrowElsChanged() {\n    if (!this.isConnected) {\n      return\n    }\n\n    this.positionArrowEls()\n  }\n\n  private setInvokeDisplayChangeCallback(): void {\n    this.invokeDisplayChangeCallback = parseFunction(this.displayChangeCallback)\n  }\n\n  private positionContentEl(direction: Direction): void {\n    const { contentEl, toggleEl } = this.state.get()\n\n    if (!(contentEl && toggleEl && this.scrollContainerEl)) {\n      return\n    }\n\n    const elRect = this.el.getBoundingClientRect()\n    const elHalfWidth = elRect.width / 2\n\n    const isDirection = {\n      bottom: direction === \"bottom-right\" || direction === \"bottom-left\",\n      left: direction === \"top-left\" || direction === \"bottom-left\",\n      right: direction === \"top-right\" || direction === \"bottom-right\",\n      top: direction === \"top-right\" || direction === \"top-left\",\n    }\n\n    let spaceTowards = {\n      bottom: document.documentElement.clientHeight - elRect.bottom,\n      left: elRect.left + elHalfWidth,\n      right: document.documentElement.clientWidth - elRect.right + elHalfWidth,\n      top: elRect.top,\n    }\n\n    let scrollContainerElRect = {\n      bottom: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n    }\n\n    // If the overlay is inside an offset parent, include all its spacings\n    // in the calculation.\n    if (this.scrollContainerEl !== document.documentElement) {\n      scrollContainerElRect = this.scrollContainerEl.getBoundingClientRect()\n\n      // Subtract toggleElChildRect from scrollContainerElRect\n      spaceTowards = {\n        bottom: scrollContainerElRect.bottom - elRect.bottom,\n        left: spaceTowards.left - scrollContainerElRect.left,\n        right: scrollContainerElRect.right - elHalfWidth,\n        top: elRect.top - scrollContainerElRect.top,\n      }\n    }\n\n    // Show the contentEl to take measurements\n    contentEl.style.display = \"block\"\n\n    const contentElWidth = contentEl.clientWidth\n    const contentElHeight = contentEl.clientHeight\n\n    const hasEnoughSpaceTo = {\n      bottom:\n        spaceTowards.bottom - MenuFlyout.minSpaceToWindow >=\n        contentElHeight + this.arrowUnrotatedWidth,\n      left: spaceTowards.left - MenuFlyout.minSpaceToWindow >= contentElWidth,\n      right: spaceTowards.right - MenuFlyout.minSpaceToWindow >= contentElWidth,\n      top:\n        spaceTowards.top - MenuFlyout.minSpaceToWindow >=\n        contentElHeight + this.arrowUnrotatedWidth,\n    }\n\n    const bottom =\n      spaceTowards.top +\n      getScrollTopLeft(this.scrollContainerEl).scrollTop +\n      elRect.height\n\n    const left =\n      spaceTowards.left +\n      getScrollTopLeft(this.scrollContainerEl).scrollLeft -\n      contentElWidth +\n      this.offsetX +\n      this.arrowUnrotatedWidth / 2\n\n    const right =\n      spaceTowards.left +\n      getScrollTopLeft(this.scrollContainerEl).scrollLeft -\n      this.offsetX -\n      this.arrowUnrotatedWidth / 2\n\n    const top =\n      spaceTowards.top +\n      getScrollTopLeft(this.scrollContainerEl).scrollTop -\n      contentElHeight\n\n    let currentDirection = direction\n\n    // Place the contentEl\n    const fallbackLeft = left < 0 ? 0 : left\n\n    if (isDirection.left) {\n      if (hasEnoughSpaceTo.left) {\n        contentEl.style.left = `${left}px`\n      } else {\n        if (hasEnoughSpaceTo.right) {\n          contentEl.style.left = `${right}px`\n          currentDirection = this.oppositeDirection.x[currentDirection]\n        } else {\n          contentEl.style.left = `${fallbackLeft}px`\n        }\n      }\n    }\n\n    if (isDirection.right) {\n      if (hasEnoughSpaceTo.right) {\n        contentEl.style.left = `${right}px`\n      } else {\n        contentEl.style.left = `${fallbackLeft}px`\n        currentDirection = this.oppositeDirection.x[currentDirection]\n      }\n    }\n\n    if (isDirection.top) {\n      if (hasEnoughSpaceTo.top) {\n        contentEl.style.top = `${top}px`\n      } else {\n        if (hasEnoughSpaceTo.bottom) {\n          contentEl.style.top = `${bottom}px`\n          currentDirection = this.oppositeDirection.y[currentDirection]\n        } else {\n          contentEl.style.top = `${top}px`\n        }\n      }\n    }\n\n    if (isDirection.bottom) {\n      if (hasEnoughSpaceTo.bottom) {\n        contentEl.style.top = `${bottom}px`\n      } else {\n        if (hasEnoughSpaceTo.top) {\n          contentEl.style.top = `${top}px`\n          currentDirection = this.oppositeDirection.y[currentDirection]\n        } else {\n          contentEl.style.top = `${bottom}px`\n        }\n      }\n    }\n\n    // Update direction\n    this.store.set(\"direction\", currentDirection)\n\n    this.positionArrowEls()\n  }\n\n  private positionArrowEls() {\n    const { contentEl, toggleEl, arrowEls } = this.state.get()\n\n    const contentElRect = contentEl!.getBoundingClientRect()\n    const toggleElRect = toggleEl!.getBoundingClientRect()\n\n    arrowEls.forEach((arrowEl) => {\n      arrowEl.style.left = `${\n        toggleElRect.left -\n        contentElRect.left +\n        toggleElRect.width / 2 -\n        this.arrowUnrotatedWidth / 2\n      }px`\n    })\n  }\n\n  public render() {\n    return <slot />\n  }\n}\n",":host {\n  display: inline-block;\n}\n","@import \"../arrow\";\n\n:host {\n  display: none; // initially closed\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: $zindex-topmost;\n  box-shadow: 0 0 4px 0 rgba($color-black, 0.2);\n  border-radius: $border-radius-large;\n\n  > .component {\n    > .body {\n      position: relative;\n      background-color: $color-white;\n      padding: $baseline-3;\n      transition: border-bottom 200ms $button-easing, color 200ms $button-easing;\n      border-radius: $border-radius-large;\n    }\n  }\n}\n\n:host(:not(:last-of-type)) {\n  > .component {\n    > .body {\n      border-bottom: 1px solid $color-aluminum-tint-2;\n    }\n  }\n}\n\n:host(.bottom-right),\n:host(.bottom-left) {\n  > .component {\n    > .arrow {\n      display: block;\n      top: -($arrow-width * 0.5);\n      box-shadow: -1px -1px 2px 0 rgba($color-black, 0.15);\n    }\n  }\n}\n\n:host(.top-right),\n:host(.top-left) {\n  > .component {\n    > .arrow {\n      display: block;\n      bottom: -($arrow-width * 0.5);\n      box-shadow: 1px 1px 2px 0 rgba($color-black, 0.15);\n    }\n  }\n}\n\n.component.sdx--dark-theme {\n  > .body,\n  > .arrow {\n    background-color: $color-dusk-tint-4-dark-theme;\n  }\n}\n\n:host(:not(:last-of-type).sdx--dark-theme) {\n  > .component {\n    > .body {\n      border-bottom: 1px solid $color-gray-tint-7-dark-theme;\n    }\n  }\n}\n","import { Component, h, State, Element, Host, Watch } from \"@stencil/core\"\nimport {\n  menuFlyoutReducer,\n  getInitialState,\n  MenuFlyoutState,\n  MenuFlyoutActions,\n} from \"../menu-flyout-store\"\nimport {\n  StoreConnection,\n  StateHandle,\n  computedProperty,\n  getAppearance,\n} from \"../../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-menu-flyout-content\",\n  styleUrl: \"menu-flyout-content.scss\",\n  shadow: true,\n})\nexport class MenuFlyoutContent {\n  private store: StoreConnection<this, MenuFlyoutState, MenuFlyoutActions>\n  private arrowEl?: HTMLElement\n  private trapFocusEl?: HTMLSdxTrapFocusElement\n\n  @Element() public el!: HTMLSdxMenuFlyoutListElement\n\n  @State() public state!: StateHandle<MenuFlyoutState>\n\n  @Watch(\"state\")\n  public stateChanged({}, prev: StateHandle<MenuFlyoutState>) {\n    const state = this.state.get()\n    const prevState = prev.get()\n\n    if (state.display !== prevState.display) {\n      this.displayChanged(state)\n    }\n  }\n\n  constructor() {\n    this.store = new StoreConnection(\n      this,\n      menuFlyoutReducer,\n      getInitialState(),\n      [\"direction\", \"display\"]\n    )\n  }\n\n  public connectedCallback() {\n    // Register self\n    this.store.set(\"contentEl\", this.el)\n\n    // Re-register arrow el (but only if already rendered)\n    if (this.arrowEl) {\n      this.store.dispatch({\n        type: \"ADD_ARROW_EL\",\n        arrowEl: this.arrowEl,\n      })\n    }\n  }\n\n  public disconnectedCallback() {\n    // Unregister arrow el (but only if already rendered)\n    // If a component is created and appended in direct succession (like with\n    // Angular's ng-content), disconnectedCallback() is called before render()\n    if (this.arrowEl) {\n      this.store.dispatch({\n        type: \"REMOVE_ARROW_EL\",\n        arrowEl: this.arrowEl,\n      })\n    }\n\n    // Unregister self\n    this.store.set(\"contentEl\", undefined)\n  }\n\n  public componentDidLoad() {\n    // Register arrow el\n    this.store.dispatch({\n      type: \"ADD_ARROW_EL\",\n      arrowEl: this.arrowEl!,\n    })\n\n    this.store.subscribe()\n  }\n\n  private displayChanged(state: MenuFlyoutState) {\n    if (state.display === \"open\") {\n      this.trapFocusEl?.doFocus()\n    }\n  }\n\n  private getHostClassNames() {\n    return {\n      ...computedProperty(this.state.get().direction),\n    }\n  }\n\n  private getComponentClassNames() {\n    return {\n      component: true,\n      [getAppearance(this.el)]: true,\n    }\n  }\n\n  public render() {\n    return (\n      <Host\n        class={this.getHostClassNames()}\n        role=\"dialog\"\n        aria-labelledby=\"sdx-dialog-content-label\"\n        aria-describedby=\"sdx-dialog-content-description\"\n      >\n        <div class={this.getComponentClassNames()}>\n          <div class=\"arrow\" ref={(el) => (this.arrowEl = el)}></div>\n\n          <div class=\"body\">\n            <sdx-trap-focus\n              ref={(el) => (this.trapFocusEl = el)}\n              lang={this.el.lang}\n            >\n              <slot />\n            </sdx-trap-focus>\n          </div>\n        </div>\n      </Host>\n    )\n  }\n}\n",":host {\n  display: none; // initially closed\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: $zindex-topmost;\n  box-shadow: 0 0 4px 0 rgba($color-black, 0.2);\n  width: 254px;\n  border-radius: $border-radius-large;\n}\n\n// so that screen readers read out the number of elements\nul {\n  list-style-type: none;\n  margin: 0;\n  padding: 0;\n}\n","import {\n  Component,\n  h,\n  Element,\n  Listen,\n  State,\n  Watch,\n  Host,\n  Prop,\n} from \"@stencil/core\"\nimport {\n  menuFlyoutReducer,\n  getInitialState,\n  MenuFlyoutActions,\n  MenuFlyoutState,\n} from \"../menu-flyout-store\"\nimport {\n  getNextFromList,\n  getPreviousFromList,\n  StoreConnection,\n  StateHandle,\n  getAppearance,\n} from \"../../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-menu-flyout-list\",\n  styleUrl: \"menu-flyout-list.scss\",\n  shadow: true,\n})\nexport class MenuFlyoutList {\n  private store: StoreConnection<this, MenuFlyoutState, MenuFlyoutActions>\n  private trapFocusEl?: HTMLSdxTrapFocusElement\n\n  @Element() public el!: HTMLSdxMenuFlyoutListElement\n\n  @State() public state!: StateHandle<MenuFlyoutState>\n\n  /**\n   * Description of the list read by the screen reader.\n   */\n  @Prop() public srHint: string = \"\"\n\n  @Watch(\"state\")\n  public stateChanged({}, prev: StateHandle<MenuFlyoutState>) {\n    const state = this.state.get()\n    const prevState = prev.get()\n\n    if (state.display !== prevState.display) {\n      this.displayChanged(state)\n    }\n  }\n\n  @Listen(\"keydown\")\n  public onKeyDown(e: KeyboardEvent) {\n    // do not save childs at componentDidLoad because they could be added dynamically or parsed async\n    const getChildsArray = () =>\n      Array.from(this.el.querySelectorAll(\"sdx-menu-flyout-list-item\"))\n\n    switch (e.key) {\n      case \"ArrowDown\":\n        const nextEl = getNextFromList(\n          getChildsArray(),\n          document.activeElement\n        ) as HTMLSdxMenuFlyoutListItemElement\n        nextEl.doFocus()\n        e.preventDefault()\n        break\n\n      case \"ArrowUp\":\n        const previousEl = getPreviousFromList(\n          getChildsArray(),\n          document.activeElement\n        ) as HTMLSdxMenuFlyoutListItemElement\n        previousEl.doFocus()\n        e.preventDefault()\n        break\n\n      case \" \":\n        const currentEl =\n          document.activeElement as HTMLSdxMenuFlyoutListItemElement\n        currentEl.doClick()\n        e.preventDefault()\n        break\n\n      default:\n        break\n    }\n  }\n\n  constructor() {\n    this.store = new StoreConnection(\n      this,\n      menuFlyoutReducer,\n      getInitialState(),\n      [\"display\"]\n    )\n  }\n\n  public connectedCallback() {\n    // Register self\n    this.store.set(\"contentEl\", this.el)\n  }\n\n  public componentDidLoad() {\n    this.store.subscribe()\n  }\n\n  private displayChanged(state: MenuFlyoutState) {\n    if (state.display === \"open\") {\n      this.trapFocusEl?.doFocus()\n    }\n  }\n\n  private getHostClassNames() {\n    return {\n      [getAppearance(this.el)]: true,\n    }\n  }\n\n  public render() {\n    return (\n      <Host\n        role=\"dialog\"\n        class={this.getHostClassNames()}\n        aria-label={this.srHint}\n      >\n        <sdx-trap-focus\n          ref={(el) => (this.trapFocusEl = el)}\n          lang={this.el.lang}\n        >\n          <div role=\"list\">\n            <slot />\n          </div>\n        </sdx-trap-focus>\n      </Host>\n    )\n  }\n}\n","@import \"../../arrow\";\n\n@mixin hover-focus-colors {\n  color: $color-white;\n  background-color: $color-int-blue !important; // !important because :first-of-type otherwise wins\n}\n\n@mixin hover-focus-colors-dark-theme {\n  color: $color-white;\n  background-color: $color-int-blue-dark-theme !important; // !important because :first-of-type otherwise wins\n}\n\n:host {\n  display: block;\n\n  > .component {\n    &.focused {\n      > .arrow,\n      > .body {\n        @include hover-focus-colors;\n      }\n    }\n\n    > .body {\n      position: relative;\n      background-color: $color-white;\n      color: $color-link;\n      display: block;\n      padding: 12px 24px;\n      text-align: center;\n      text-decoration: none;\n      transition: border-bottom 200ms $button-easing, color 200ms $button-easing;\n      outline: none;\n    }\n  }\n}\n\n:host(.selectable) {\n  > .component {\n    > .body {\n      cursor: pointer;\n    }\n  }\n}\n\n:host(:not(.selectable)) {\n  > .component {\n    > .body {\n      cursor: not-allowed;\n    }\n  }\n}\n\n:host(.selectable:hover) {\n  > .component {\n    > .arrow,\n    > .body {\n      @include hover-focus-colors;\n    }\n  }\n}\n\n:host(.disabled) {\n  > .component {\n    > .body {\n      @include disabled;\n      color: $color-disabled;\n    }\n  }\n}\n\n:host(:first-of-type) {\n  > .component {\n    > .body {\n      border-radius: $border-radius-large $border-radius-large 0 0;\n    }\n  }\n}\n\n:host(:last-of-type) {\n  > .component {\n    > .body {\n      border-radius: 0 0 $border-radius-large $border-radius-large;\n    }\n  }\n}\n\n:host(:not(:last-of-type)) {\n  > .component {\n    > .body {\n      border-bottom: 1px solid $color-aluminum-tint-2;\n    }\n  }\n}\n\n:host(.bottom-right:first-of-type),\n:host(.bottom-left:first-of-type) {\n  > .component {\n    > .arrow {\n      display: block;\n      top: -($arrow-width * 0.5);\n      box-shadow: -1px -1px 2px 0 rgba($color-black, 0.15);\n    }\n  }\n}\n\n:host(.top-right:last-of-type),\n:host(.top-left:last-of-type) {\n  > .component {\n    > .arrow {\n      display: block;\n      bottom: -($arrow-width * 0.5);\n      box-shadow: 1px 1px 2px 0 rgba($color-black, 0.15);\n    }\n  }\n}\n\n:host(.sdx--dark-theme) {\n  > .component {\n    &.focused {\n      > .arrow,\n      > .body {\n        @include hover-focus-colors-dark-theme;\n      }\n    }\n\n    > .body {\n      @include font-plain;\n      background-color: $color-dusk-tint-4-dark-theme;\n      color: $color-int-blue2-dark-theme;\n    }\n  }\n}\n\n:host(.sdx--dark-theme) {\n  > .component {\n    > .arrow {\n      background-color: $color-dusk-tint-4-dark-theme;\n    }\n  }\n}\n\n:host(.sdx--dark-theme.selectable:hover) {\n  > .component {\n    > .arrow,\n    > .body {\n      @include hover-focus-colors-dark-theme;\n    }\n  }\n}\n\n:host(.disabled.sdx--dark-theme) {\n  > .component {\n    > .body {\n      color: $color-disabled-dark-theme;\n    }\n  }\n}\n\n:host(:not(:last-of-type).sdx--dark-theme) {\n  > .component {\n    > .body {\n      border-bottom: 1px solid $color-gray-tint-7-dark-theme;\n    }\n  }\n}\n","import {\n  Component,\n  h,\n  Prop,\n  State,\n  Element,\n  Listen,\n  Host,\n  Method,\n} from \"@stencil/core\"\nimport {\n  menuFlyoutReducer,\n  getInitialState,\n  MenuFlyoutState,\n  MenuFlyoutActions,\n} from \"../../menu-flyout-store\"\nimport {\n  StoreConnection,\n  StateHandle,\n  computedProperty,\n  getAppearance,\n} from \"../../../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-menu-flyout-list-item\",\n  styleUrl: \"menu-flyout-list-item.scss\",\n  shadow: true,\n})\nexport class MenuFlyoutListItem {\n  private store: StoreConnection<this, MenuFlyoutState, MenuFlyoutActions>\n  private arrowEl?: HTMLElement\n  private anchorEl?: HTMLElement\n\n  @Element() public el!: HTMLSdxMenuFlyoutElement\n\n  @State() public state!: StateHandle<MenuFlyoutState>\n\n  @State() private anchorElFocused: boolean = false\n\n  /**\n   * If the item is not selectable, it is neither highlighted nor does it have cursor: pointer.\n   */\n  @Prop() public selectable: boolean = true\n\n  /**\n   * The URL this item should link to (if it’s a regular link not handled by JS).\n   */\n  @Prop() public href: string = \"javascript:;\"\n\n  /**\n   * Language of the page the URL points to.\n   */\n  @Prop() public hreflang?: string\n\n  /**\n   * Target of the link (\"_blank\", \"_parent\", \"_top\", \"_self\", or the name of a window or frame)\n   */\n  @Prop() public target?: string\n\n  /**\n   * Whether the item is disabled.\n   */\n  @Prop() public disabled: boolean = false\n\n  @Listen(\"click\", { capture: true })\n  public onClick(e: MouseEvent) {\n    if (this.disabled) {\n      e.stopPropagation()\n    }\n  }\n\n  @Listen(\"focusin\")\n  @Listen(\"focusout\")\n  public onFocusChange() {\n    this.anchorElFocused = !this.anchorElFocused\n  }\n\n  @Method()\n  public async doFocus() {\n    this.anchorEl!.focus()\n  }\n\n  @Method()\n  public async doClick() {\n    this.anchorEl!.click()\n  }\n\n  constructor() {\n    this.store = new StoreConnection(\n      this,\n      menuFlyoutReducer,\n      getInitialState(),\n      [\"direction\"]\n    )\n  }\n\n  public connectedCallback() {\n    // Re-register arrow el (but only if already rendered)\n    if (this.arrowEl) {\n      this.store.dispatch({\n        type: \"ADD_ARROW_EL\",\n        arrowEl: this.arrowEl,\n      })\n    }\n  }\n\n  public disconnectedCallback() {\n    // Unregister arrow el (but only if already rendered)\n    // If a component is created and appended in direct succession (like with\n    // Angular's ng-content), disconnectedCallback() is called before render()\n    if (this.arrowEl) {\n      this.store.dispatch({\n        type: \"REMOVE_ARROW_EL\",\n        arrowEl: this.arrowEl,\n      })\n    }\n  }\n\n  public componentDidLoad() {\n    // Register arrow el\n    this.store.dispatch({\n      type: \"ADD_ARROW_EL\",\n      arrowEl: this.arrowEl!,\n    })\n\n    this.store.subscribe()\n  }\n\n  private getHostClassNames() {\n    const { direction } = this.state.get()\n\n    return {\n      [getAppearance(this.el)]: true,\n      selectable: this.selectable && !this.disabled,\n      disabled: this.disabled,\n      ...computedProperty(direction),\n    }\n  }\n\n  private getComponentClassNames() {\n    return {\n      component: true,\n      focused: this.anchorElFocused,\n    }\n  }\n\n  private getLinkClassNames() {\n    return {\n      body: true,\n      disabled: this.disabled,\n    }\n  }\n\n  public render() {\n    return (\n      // eslint-disable-next-line jsx-a11y/role-supports-aria-props\n      <Host\n        class={this.getHostClassNames()}\n        aria-disabled={this.disabled && \"true\"}\n        role=\"listitem\"\n      >\n        <div class={this.getComponentClassNames()}>\n          <div class=\"arrow\" ref={(el) => (this.arrowEl = el)}></div>\n\n          <a\n            href={this.href}\n            hreflang={this.hreflang}\n            target={this.target}\n            class={this.getLinkClassNames()}\n            ref={(el) => (this.anchorEl = el)}\n          >\n            <slot />\n          </a>\n        </div>\n      </Host>\n    )\n  }\n}\n",".toggle {\n  padding: 0;\n  background-color: transparent;\n  color: $color-int-blue;\n\n  border: none;\n  font: inherit;\n\n  outline: none;\n  cursor: pointer;\n\n  &:hover,\n  &:focus-visible {\n    color: $color-int-blue--active;\n  }\n}\n\n.toggle.sdx--dark-theme {\n  color: $color-int-blue2-dark-theme;\n\n  &:hover,\n  &:focus-visible {\n    color: $color-int-blue2-dark-theme--active;\n  }\n}\n","import { Component, h, Element, Listen, State, Method } from \"@stencil/core\"\nimport {\n  menuFlyoutReducer,\n  getInitialState,\n  MenuFlyoutActions,\n  MenuFlyoutState,\n} from \"../menu-flyout-store\"\nimport {\n  StoreConnection,\n  StateHandle,\n  translate,\n  getAppearance,\n} from \"../../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-menu-flyout-toggle\",\n  styleUrl: \"menu-flyout-toggle.scss\",\n  shadow: true,\n})\nexport class MenuFlyoutToggle {\n  private store: StoreConnection<this, MenuFlyoutState, MenuFlyoutActions>\n  private buttonEl?: HTMLButtonElement\n\n  @Element() public el!: HTMLSdxMenuFlyoutToggleElement\n\n  @State() public state!: StateHandle<MenuFlyoutState>\n\n  /**\n   * Sets the focus on the component.\n   */\n  @Method()\n  public async doFocus() {\n    this.buttonEl?.focus()\n  }\n\n  @Listen(\"click\")\n  public onClick() {\n    this.store.set(\"userInteractionInProgress\", true)\n    this.state.get().toggle()\n    this.store.set(\"userInteractionInProgress\", false)\n  }\n\n  @Listen(\"keydown\")\n  public handleKeyDown(e: KeyboardEvent) {\n    const key = e.key\n\n    if (key === \"Spacebar\" || key === \" \" || key === \"Enter\") {\n      e.preventDefault() // prevent scrolling, for space\n      this.store.set(\"userInteractionInProgress\", true)\n      this.state.get().toggle()\n      this.store.set(\"userInteractionInProgress\", false)\n    }\n  }\n\n  constructor() {\n    this.store = new StoreConnection(\n      this,\n      menuFlyoutReducer,\n      getInitialState(),\n      [\"display\", \"toggle\"]\n    )\n  }\n\n  public connectedCallback() {\n    // Register self\n    this.store.set(\"toggleEl\", this.el)\n  }\n\n  public disconnectedCallback() {\n    // Unregister self\n    this.store.set(\"toggleEl\", undefined)\n  }\n\n  public componentDidLoad() {\n    this.store.subscribe()\n  }\n\n  private getButtonClassNames() {\n    return {\n      toggle: true,\n      [getAppearance(this.el)]: true,\n    }\n  }\n\n  public render() {\n    return (\n      <button\n        type=\"button\"\n        class={this.getButtonClassNames()}\n        ref={(el) => (this.buttonEl = el)}\n        aria-label={translate(\"Open dialog\", this.el.lang)}\n      >\n        <slot />\n      </button>\n    )\n  }\n}\n","export default function _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}"],"names":["add","list","item","includes","remove","filter","currentItem","toggle","objectMap","obj","cb","newObj","key","menuFlyoutReducer","state","action","type","arrowEls","arrowEl","getInitialState","display","direction","Promise","resolve","contentEl","undefined","userInteractionInProgress","toggleEl","MenuFlyout","isConnected","invokeDisplayChangeCallback","animationDuration","oppositeDirection","x","y","arrowUnrotatedWidth","offsetX","offsetY","lastScreenOrientationAngle","this","setInvokeDisplayChangeCallback","store","StoreConnection","set","bind","flush","prev","get","prevState","displayChanged","arrowElsChanged","close","then","open","currentAngle","getScreenOrientationAngle","positionContentEl","overlayOutletEl","getOverlayOutletEl","scrollContainerEl","getScrollContainerEl","el","document","documentElement","appendToOverlayOutlet","style","opacity","transform","setDisplay","anime","targets","duration","animated","translateY","easing","complete","e","KeyboardEvent","composedPath","closeOnClick","subscribe","sdxdisplaychange","emit","positionArrowEls","parseFunction","displayChangeCallback","elRect","getBoundingClientRect","elHalfWidth","width","isDirection","spaceTowards","bottom","clientHeight","left","right","clientWidth","top","scrollContainerElRect","contentElWidth","contentElHeight","hasEnoughSpaceTo","minSpaceToWindow","getScrollTopLeft","scrollTop","height","scrollLeft","currentDirection","fallbackLeft","contentElRect","toggleElRect","forEach","h","MenuFlyoutContent","dispatch","trapFocusEl","_a","doFocus","computedProperty","component","getAppearance","Host","class","getHostClassNames","role","getComponentClassNames","ref","lang","MenuFlyoutList","getChildsArray","Array","from","querySelectorAll","getNextFromList","activeElement","preventDefault","getPreviousFromList","doClick","srHint","MenuFlyoutListItem","disabled","stopPropagation","anchorElFocused","anchorEl","focus","click","selectable","focused","body","href","hreflang","target","getLinkClassNames","MenuFlyoutToggle","buttonEl","getButtonClassNames","translate","_objectDestructuringEmpty","TypeError"],"sourceRoot":""}