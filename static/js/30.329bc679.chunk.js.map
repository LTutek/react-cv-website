{"version":3,"file":"static/js/30.329bc679.chunk.js","mappings":"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","sources":["../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/core/helpers/breakpoint-helpers.ts","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/core/helpers/immutability-helpers.ts","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/select/select-store.ts","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/select/select.scss?tag=sdx-select&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/select/select.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/select/select-list/select-list.scss?tag=sdx-select-list&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/select/select-list/select-list.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/select/select-optgroup/select-optgroup.scss?tag=sdx-select-optgroup&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/select/select-optgroup/select-optgroup.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/select/select-option/select-option.scss?tag=sdx-select-option&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/select/select-option/select-option.tsx","../node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js"],"sourcesContent":["type Breakpoints = {\n  xs: 0\n  sm: 480\n  md: 768\n  lg: 1024\n  xl: 1280\n  ul: 1440\n}\n\nexport const breakpoints: Breakpoints = {\n  xs: 0,\n  sm: 480,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  ul: 1440,\n}\n\nexport function bp(breakpoint: keyof Breakpoints) {\n  return window.innerWidth >= breakpoints[breakpoint]\n}\n","/**\n * Adds an item to a list, if it does not exist, yet.\n * @param list The array that might contain the given item.\n * @param item The element that should be added.\n */\nexport function add<I>(list: I[], item: I): I[] {\n  if (!list.includes(item)) {\n    return [...list, item]\n  }\n\n  return list\n}\n\n/**\n * Removes an item from a list, if it exists.\n * @param list The array that might contain the given item.\n * @param item The element that should be removed.\n */\nexport function remove<I>(list: I[], item: I): I[] {\n  if (list.includes(item)) {\n    return list.filter((currentItem) => currentItem !== item)\n  }\n\n  return list\n}\n\n/**\n * Adds an item to a list, if it does not exist, yet.\n * If it does exist, however, it removes it.\n * @param list The array that might contain the given item.\n * @param item The element that should be added or removed.\n */\nexport function toggle<I>(list: I[], item: I): I[] {\n  if (!list.includes(item)) {\n    return add(list, item)\n  }\n\n  return remove(list, item)\n}\n\n/**\n * Like Array map() but for objects.\n * Example: { foo: \"bar\" } => { foo1: \"bar1\" }\n * @param obj Object to iterate.\n * @param cb Callback that transforms key and value.\n */\nexport function objectMap(\n  obj: Record<string, unknown> | undefined,\n  cb: (key: string, value: unknown) => Record<string, unknown>\n): Record<string, unknown> {\n  let newObj: Record<string, unknown> = {}\n\n  for (const key in obj) {\n    newObj = { ...newObj, ...cb(key, obj[key]) }\n  }\n\n  return newObj\n}\n","import { Reducer } from \"redux\"\nimport { DirectionX, DirectionY, KeyboardBehavior, Strategy } from \"./types\"\nimport { sortByAppearanceInDomTree } from \"../../core/helpers/webcomponent-helpers\"\nimport { add, remove } from \"../../core/helpers/immutability-helpers\"\nimport { Display } from \"../../core/types/types\"\n\nexport interface SelectState {\n  selection: HTMLSdxSelectOptionElement[]\n  multiple: boolean\n  directionX: DirectionX\n  directionY: DirectionY\n  keyboardBehavior: KeyboardBehavior\n  listEl?: HTMLSdxSelectListElement\n  sort: boolean\n  optionEls: HTMLSdxSelectOptionElement[]\n  optgroupEls: HTMLSdxSelectOptgroupElement[]\n  name?: string\n  filter: string\n  filterable: boolean\n  filterInputElValue: string\n  filterInputElPlaceholder: string\n  filterMinLength: number\n  noMatchesFound: boolean\n  noMatchesFoundLabel: string\n  animationDuration: number\n  reappending: boolean\n  reappendedItems: number\n  connected: boolean\n  userInteractionInProgress: boolean\n  placeholder: string\n  required: boolean\n  display: Display\n  loading: boolean\n  close(): Promise<void>\n  isInsideDialog: boolean\n}\n\nexport type SelectActions =\n  | {\n      type: \"SELECT\"\n      optionEl: HTMLSdxSelectOptionElement | null\n      strategy: Strategy\n    }\n  | { type: \"ACTIVATE_SORT\" }\n  | { type: \"ADD_OPTION_EL\"; optionEl: HTMLSdxSelectOptionElement }\n  | { type: \"REMOVE_OPTION_EL\"; optionEl: HTMLSdxSelectOptionElement }\n  | {\n      type: \"ADD_OPTGROUP_EL\"\n      optgroupEl: HTMLSdxSelectOptgroupElement\n    }\n  | {\n      type: \"REMOVE_OPTGROUP_EL\"\n      optgroupEl: HTMLSdxSelectOptgroupElement\n    }\n  | { type: \"SET_FILTER\"; filter: SelectState[\"filter\"] }\n  | {\n      type: \"SET_VALIDATED_FILTER_INPUT_EL_VALUE\"\n      filterInputElValue: SelectState[\"filterInputElValue\"]\n    }\n  | { type: \"UPDATE_REAPPENDING\" }\n\n/**\n * Get the text that will be displayed in the selection header.\n * Fall back to an empty string if there's no selection.\n */\nexport function getFormattedSelection(\n  selection: HTMLSdxSelectOptionElement[]\n): string {\n  return selection.length ? selection.map(getDisplayText).join(\", \") : \"\"\n}\n\n/**\n * Checks if a given \"keyboard-behavior\" is active, including backwards\n * compatibility with the deprecated \"filterable\" prop.\n * @param store Context with store properties.\n * @param keyboardBehavior Behavior to test.\n */\nexport function isKeyboardBehavior(\n  store: SelectState,\n  keyboardBehavior: KeyboardBehavior\n): boolean {\n  const isMatch = keyboardBehavior === store.keyboardBehavior\n\n  if (keyboardBehavior === \"filter\" && (isMatch || store.filterable)) {\n    return true\n  }\n\n  return isMatch\n}\n\nexport function isFilterLongEnough(\n  filter: string,\n  filterMinLength: number\n): boolean {\n  return filter.length > 0 && filter.length >= filterMinLength\n}\n\nexport function isValidFilter(\n  filter: string,\n  selection: HTMLSdxSelectOptionElement[],\n  filterMinLength: number\n): boolean {\n  return (\n    isFilterLongEnough(filter, filterMinLength) &&\n    filter !== getFormattedSelection(selection) // Ignore selection as filter\n  )\n}\n\nexport function getDisplayText(optionEl: HTMLSdxSelectOptionElement): string {\n  return optionEl.displayText || optionEl.textContent?.trim() || \"\"\n}\n\nexport const selectReducer: Reducer<SelectState, SelectActions> = (\n  state = {} as SelectState,\n  action\n): SelectState => {\n  switch (action.type) {\n    case \"SELECT\":\n      let { selection } = state\n\n      if (action.optionEl) {\n        // selecting a \"real\" option (not the placeholder)\n        if (state.multiple) {\n          // multi-select\n          const alreadySelected = selection.includes(action.optionEl)\n\n          if (alreadySelected || action.strategy === \"remove\") {\n            // remove from selection\n            selection = selection.filter(\n              (optionEl) => optionEl !== action.optionEl\n            )\n          } else {\n            // \"add\" to selection\n            selection = [...selection, action.optionEl].sort(\n              sortByAppearanceInDomTree\n            )\n          }\n        } else {\n          // single select\n          const alreadySelected = selection[0] === action.optionEl\n\n          if (alreadySelected) {\n            if (action.strategy === \"remove\") {\n              selection = []\n            }\n          } else {\n            if (action.strategy === \"add\") {\n              selection = [action.optionEl]\n            }\n          }\n        }\n      } else {\n        // selecting the placeholder\n        if (selection.length) {\n          // Only create a new array if the selection isn't empty\n          // to prevent unnecessary change detection.\n          selection = []\n        }\n      }\n\n      return { ...state, selection }\n\n    case \"ACTIVATE_SORT\":\n      return {\n        ...state,\n        sort: true,\n        optionEls: [...state.optionEls].sort(sortByAppearanceInDomTree),\n      }\n\n    case \"ADD_OPTION_EL\":\n      return {\n        ...state,\n        optionEls: state.sort\n          ? add(state.optionEls, action.optionEl).sort(\n              sortByAppearanceInDomTree\n            )\n          : add(state.optionEls, action.optionEl),\n      }\n\n    case \"REMOVE_OPTION_EL\":\n      return {\n        ...state,\n        optionEls: state.sort\n          ? remove(state.optionEls, action.optionEl).sort(\n              sortByAppearanceInDomTree\n            )\n          : remove(state.optionEls, action.optionEl),\n      }\n\n    case \"ADD_OPTGROUP_EL\":\n      return {\n        ...state,\n        optgroupEls: state.sort\n          ? add(state.optgroupEls, action.optgroupEl).sort(\n              sortByAppearanceInDomTree\n            )\n          : add(state.optgroupEls, action.optgroupEl),\n      }\n\n    case \"REMOVE_OPTGROUP_EL\":\n      return {\n        ...state,\n        optgroupEls: state.sort\n          ? remove(state.optgroupEls, action.optgroupEl).sort(\n              sortByAppearanceInDomTree\n            )\n          : remove(state.optgroupEls, action.optgroupEl),\n      }\n\n    case \"SET_FILTER\":\n      return {\n        ...state,\n        filter: isValidFilter(\n          action.filter,\n          state.selection,\n          state.filterMinLength\n        )\n          ? action.filter\n          : \"\",\n      }\n\n    case \"SET_VALIDATED_FILTER_INPUT_EL_VALUE\":\n      return {\n        ...state,\n        filterInputElValue: isValidFilter(\n          action.filterInputElValue,\n          state.selection,\n          state.filterMinLength\n        )\n          ? action.filterInputElValue\n          : \"\",\n      }\n\n    case \"UPDATE_REAPPENDING\":\n      const reappendedItems = state.reappendedItems + 1\n      const reappending =\n        reappendedItems !== state.optionEls.length + state.optgroupEls.length\n\n      return {\n        ...state,\n        reappending,\n        reappendedItems: reappending ? reappendedItems : 0,\n      }\n\n    default:\n      return state\n  }\n}\n\nexport function getInitialState(): SelectState {\n  return {\n    selection: [],\n    multiple: false,\n    directionX: \"right\",\n    directionY: \"bottom\",\n    keyboardBehavior: \"focus\",\n    listEl: undefined,\n    sort: false,\n    optionEls: [],\n    optgroupEls: [],\n    name: undefined,\n    filter: \"\",\n    filterable: false,\n    filterInputElValue: \"\",\n    filterInputElPlaceholder: \"\",\n    filterMinLength: 3,\n    noMatchesFound: false,\n    noMatchesFoundLabel: \"\",\n    animationDuration: 0,\n    reappending: false,\n    reappendedItems: 0,\n    connected: false,\n    userInteractionInProgress: false,\n    placeholder: \"\",\n    required: false,\n    display: \"closed\",\n    loading: false,\n    close: () => Promise.resolve(),\n    isInsideDialog: false,\n  }\n}\n","@import \"../../globals/scss/label\";\n\n:host {\n  outline: none; // For tabindex\n}\n\n.component {\n  .header-wrapper {\n    // Needed for the thumb that overflows the border with 1px\n    overflow: hidden;\n\n    .header {\n      position: relative;\n\n      .thumb {\n        width: 30px;\n        position: absolute;\n        right: -1px;\n        top: -1px;\n        bottom: -1px;\n\n        // Make sure the .thumb doesn't receive focus on click.\n        // Instead, \"forward\" the focus to the component to guarantee the focus border.\n        pointer-events: none;\n\n        // Spinner\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > .icon {\n          @include arrow($color-int-blue);\n          @include arrow--down;\n          width: 100%;\n          transform-origin: 50% 50%;\n        }\n      }\n\n      &:hover {\n        cursor: pointer;\n\n        .thumb {\n          > .icon {\n            @include arrow($color-int-blue--active);\n          }\n        }\n      }\n    }\n  }\n}\n\n// Open/opening\n.component.open,\n.component.opening {\n  .header-wrapper {\n    box-shadow: 0 0 4px 0 rgba($color-gray, 0.1);\n\n    .header {\n      .thumb {\n        > .icon {\n          @include arrow--up;\n        }\n      }\n    }\n  }\n}\n\n// Open/opening/closing towards bottom\n.component.bottom {\n  .header-wrapper {\n    border-radius: $border-radius $border-radius 0 0;\n  }\n}\n\n// Open/opening/closing towards top\n.component.top {\n  .header-wrapper {\n    border-radius: 0 0 $border-radius $border-radius;\n  }\n}\n\n.component.disabled,\n.component.loading {\n  .label,\n  .wrapper {\n    pointer-events: none; // ensure sdx-select can't be opened\n  }\n}\n\n.component.disabled {\n  cursor: not-allowed;\n\n  .label {\n    color: $color-input-item-disabled;\n  }\n\n  .header-wrapper .header .thumb .icon {\n    &::before,\n    &::after {\n      background-color: $color-input-item-disabled;\n    }\n  }\n}\n\n.component.loading {\n  sdx-loading-spinner {\n    position: relative;\n    right: $baseline;\n  }\n}\n\n.component.focus {\n  sdx-validation-message {\n    display: none;\n  }\n}\n\n.component.dark {\n  .label {\n    color: $color-white;\n  }\n}\n\n.component.autocomplete {\n  .header:hover {\n    cursor: unset; // otherwise cursor \"pointer\" is shown\n  }\n\n  &:not(.loading) {\n    .header-wrapper {\n      .header {\n        padding-right: 0;\n      }\n    }\n  }\n}\n\n.component.invalid:not(.focus) {\n  .header-wrapper {\n    .header {\n      .thumb {\n        > .icon {\n          @include arrow($color-input-invalid-form);\n        }\n      }\n\n      &:hover {\n        .thumb {\n          > .icon {\n            @include arrow($color-input-invalid-form-hover);\n          }\n        }\n      }\n    }\n  }\n}\n\n.component.sdx--dark-theme {\n  .header-wrapper {\n    .header {\n      .thumb {\n        > .icon {\n          @include arrow($color-int-blue2-dark-theme);\n        }\n      }\n\n      &:hover {\n        .thumb {\n          > .icon {\n            @include arrow($color-int-blue2-dark-theme--active);\n          }\n        }\n      }\n    }\n  }\n}\n\n.component.open.sdx--dark-theme,\n.component.opening.sdx--dark-theme {\n  .header-wrapper {\n    box-shadow: none;\n  }\n}\n\n.component.disabled.sdx--dark-theme {\n  .label {\n    color: $color-disabled-dark-theme;\n  }\n\n  .header-wrapper .header .thumb .icon {\n    &::before,\n    &::after {\n      background: $color-disabled-dark-theme;\n    }\n  }\n}\n\n.component.invalid:not(.focus).sdx--dark-theme {\n  .header-wrapper {\n    .header {\n      .thumb {\n        > .icon {\n          @include arrow($color-invalid-dark-theme);\n        }\n      }\n\n      &:hover {\n        .thumb {\n          > .icon {\n            @include arrow($color-invalid-dark-theme--active);\n          }\n        }\n      }\n    }\n  }\n}\n","import {\n  Component,\n  h,\n  Element,\n  State,\n  Prop,\n  Event,\n  EventEmitter,\n  Watch,\n  Listen,\n  Method,\n  Host,\n} from \"@stencil/core\"\nimport anime from \"animejs\"\nimport { KeyboardBehavior, DirectionX, DirectionY } from \"./types\"\nimport {\n  selectReducer,\n  getInitialState,\n  getFormattedSelection,\n  isKeyboardBehavior,\n  isValidFilter,\n  isFilterLongEnough,\n  SelectState,\n  SelectActions,\n} from \"./select-store\"\nimport { bp } from \"../../core/helpers/breakpoint-helpers\"\nimport {\n  StoreConnection,\n  StateHandle,\n  parseFunction,\n  getPreviousFromList,\n  getNextFromList,\n  closest,\n  getOverlayOutletEl,\n  sortByAppearanceInDomTree,\n  dispatchEvent,\n  getScrollContainerEl,\n  getScreenOrientationAngle,\n  getAppearance,\n  appendToOverlayOutlet,\n  getScrollTopLeft,\n  isTouchscreen,\n  translate,\n} from \"../../core/helpers/webcomponent-helpers\"\nimport { BackgroundTheme } from \"../../core/types/types\"\n\n@Component({\n  tag: \"sdx-select\",\n  styleUrl: \"select.scss\",\n  shadow: true,\n})\nexport class Select {\n  private store: StoreConnection<this, SelectState, SelectActions>\n  private overlayOutletEl?: Element\n  private scrollContainerEl?: Element\n  private componentEl?: HTMLDivElement\n  private wrapperEl?: HTMLDivElement\n  private filterInputEl?: HTMLSdxInputElement\n  private nonEditableInputEl?: HTMLSdxInputElement\n  private focussedEl?: HTMLSdxSelectOptionElement\n  private invokeSelectCallback: Function = () => null\n  private invokeChangeCallback: Function = () => null\n  private invokeFilterCallback: Function = () => null\n  private invokeFocusCallback: Function = () => null\n  private invokeBlurCallback: Function = () => null\n  private isTabDown = false\n  private componentDidLoadComplete = false\n  private hadFilterInputElFocus = false\n  private isReappending = false\n  private animationDuration = 200\n  private resizeTimer?: NodeJS.Timer\n  private hasConsumerProvidedListEl = false\n  private maxAutocompleteOptions\n\n  private parsedFilterFunction: (\n    optionEl: HTMLSdxSelectOptionElement,\n    filter: string\n  ) => boolean = () => true\n\n  private visualViewportResizeHandler = () => {\n    // triggered on virtual keyboard toggle\n    const { listEl, isInsideDialog } = this.state.get()\n\n    if (\n      this.isClosedOrClosing() ||\n      !listEl ||\n      !visualViewport ||\n      !isInsideDialog\n    ) {\n      return\n    }\n\n    const spaceMovedUpByiOS = window.innerHeight - visualViewport.height // visualViewport.offsetTop is always 0 on iPad\n    const virtualKeyboardVisible = spaceMovedUpByiOS > 10 // event triggered before offsetTop is getting 0 on iPhone (but not on iPad)\n    const listElRectTop = listEl.getBoundingClientRect().top\n\n    if (virtualKeyboardVisible) {\n      listEl.style.maxHeight = `${visualViewport.height - listElRectTop}px`\n    } else {\n      listEl.style.maxHeight = \"\"\n    }\n  }\n\n  private static readonly maxAutocompleteOptionsMobile = 5\n  private static readonly maxAutocompleteOptionsDesktop = 10\n  private static readonly minSpaceToWindow = 24 // $baseline-3\n  private static readonly selectHeight = 48 // $select-height\n\n  // When the selection changes by setting `this.value = [ \"one\", \"two\", ... ]`,\n  // the selected options will be updated - but syncing back to \"this.value\" is\n  // necessary, as long as `this.value` is valid.\n  // These flag control in which way the sync happens.\n  private valueChangedInProgress = false\n  private filterInputElValueChangedInProgress = false\n  private selectionChangedInProgress = false\n\n  // A \"native\" hidden DOM element that is submitted when the item is used in a\n  // traditional form.\n  // Only used when `keyboard-behavior=\"autocomplete\"`. In all other cases,\n  // the hidden DOM elements of each selected sdx-select-option are read\n  // instead.\n  private lightDOMHiddenFormInputEl?: HTMLInputElement\n  private dialogEl?: HTMLSdxDialogElement\n  private dialogContentEl?: HTMLSdxDialogContentElement\n\n  private optionElsDidUpdate = false\n  private lastScreenOrientationAngle = 0\n\n  /**\n   * Emitted whenever the user is selecting an option or typing while\n   * `keyboard-behavior=\"autocomplete\"`.\n   * @event\n   */\n  private static eventInput = \"input\"\n\n  /**\n   * Emitted when the input gets focus.\n   * Used when `keyboard-behavior=\"filter\"` or `keyboard-behavior=\"autocomplete\"`.\n   * @event\n   */\n  // @ts-ignore just for documentation purposes\n  private static eventFocus = \"focus\"\n\n  /**\n   * Emitted when the input loses focus.\n   * Used when `keyboard-behavior=\"filter\"` or `keyboard-behavior=\"autocomplete\"`.\n   * @event\n   */\n  // @ts-ignore just for documentation purposes\n  private static eventBlur = \"blur\"\n\n  @Element() public el!: HTMLSdxSelectElement\n\n  @State() public state!: StateHandle<SelectState>\n\n  @State() private focussed = false\n  @State() private isChildOfSdxFilter = false\n\n  /**\n   * Text to be displayed when nothing is selected.\n   */\n  @Prop() public placeholder: string = \"\"\n\n  /**\n   * Enable multi select.\n   */\n  @Prop() public multiple: boolean = false\n\n  /**\n   * Will be written on the top of the sdx-select.\n   */\n  @Prop({ reflect: true }) public label?: string\n\n  /**\n   * Description text read by the screen reader.\n   * Will be appended to the loading spinner when `loading=\"true\"`.\n   */\n  @Prop() public srHint: string = \"\"\n\n  /**\n   * Disables the sdx-select.\n   */\n  @Prop() public disabled: boolean = false\n\n  /**\n   * Shows a loading spinner and disables the `sdx-select`. Useful for async\n   * data fetching. It also makes sure that the `noMatchesFoundLabel` won't\n   * show. Don't forget to set srHint accordingly.\n   * It's best practice to wait about 1s before showing. For loading times\n   * longer than 10s consider a skeleton instead.\n   */\n  @Prop() public loading: boolean = false\n\n  /**\n   * How the component should behave when the user types something on the\n   * keyboard:\n   * `\"focus\"` jumps to and focuses the option starting with the typed character.\n   * `\"filter\"` lists only options (and optgroups) that match the entered filter.\n   * `\"autocomplete\"` is similar to `\"filter\"`, but makes the component behave\n   * more like an input field, e.g. the `.value` reflects the content of the\n   * filter and there is no thumb to open or close.\n   */\n  @Prop() public keyboardBehavior: KeyboardBehavior = \"focus\"\n\n  /**\n   * Shows a search icon when `keyboard-behavior=\"autocomplete\"`.\n   */\n  @Prop() public type?: \"search\"\n\n  /**\n   * Filter the options of the sdx-select by typing.\n   * Shortcut for `keyboard-behavior=\"filter\"`.\n   * @deprecated use \"keyboard-behavior\" instead.\n   */\n  @Prop() public filterable: boolean = false\n\n  /**\n   * Maximum dropdown height (e.g. `300px`), supported units are `px` and `vh`.\n   * If no unit is provided, `px` will be used.\n   */\n  @Prop() public maxHeight?: string | number\n\n  /**\n   * Callback when an option is selected (and the select is *not* in\n   * `autocomplete` mode).\n   * @deprecated use input event instead.\n   */\n  @Prop() public selectCallback?: ((selection: any[]) => void) | string\n\n  /**\n   * Callback when an option is selected (or something was typed, when\n   * `keyboard-behavior=\"autocomplete\"`).\n   * @deprecated use input event instead.\n   */\n  @Prop() public changeCallback?: ((selection: any[]) => void) | string\n\n  /**\n   * Callback when the user changed the filter keyword.\n   * Used when `keyboard-behavior=\"filter\"`.\n   * @deprecated use sdxfilter event instead.\n   */\n  @Prop() public filterCallback?: ((keyword: string) => void) | string\n\n  /**\n   * Callback when the input gets focus.\n   * Used when `keyboard-behavior=\"filter\"` or `keyboard-behavior=\"autocomplete\"`.\n   * @deprecated use focus event instead.\n   */\n  @Prop() public focusCallback?: (() => void) | string\n\n  /**\n   * Callback when the input loses focus.\n   * Used when `keyboard-behavior=\"filter\"` or `keyboard-behavior=\"autocomplete\"`.\n   * @deprecated use blur event instead.\n   */\n  @Prop() public blurCallback?: (() => void) | string\n\n  /**\n   * Label text for \"No matches found\".\n   */\n  @Prop() public noMatchesFoundLabel: string = translate(\n    \"No matches found...\",\n    this.el.lang\n  )\n\n  /**\n   * Background color scheme.\n   */\n  @Prop() public backgroundTheme: BackgroundTheme = \"light\"\n\n  /**\n   * The value(s) of the currently selected option(s).\n   * Please note that this is always an array, even without the `\"multiple\"`\n   * attribute, for both getting and setting the value, like\n   * `mySelect.value = [ \"value1\" ]`.\n   * Note that when being used for setting the initial value, the \"selected\"\n   * attribute on the `<sdx-select-option />` has\n   * the higher priority.\n   */\n  @Prop({ mutable: true }) public value: any[] = []\n\n  /**\n   * Name parameter (useful when the component is used in a traditional HTML\n   * form submit).\n   */\n  @Prop() public name?: string\n\n  /**\n   * Function that decides whether an option element matches a filter by\n   * returning true or false. Defaults to a function that performs a simple\n   * string match test on the option elements textContent property.\n   * Used when `keyboard-behavior=\"filter\"` or `keyboard-behavior=\"autocomplete\"`.\n   */\n  @Prop() public filterFunction?:\n    | ((optionEl: HTMLSdxSelectOptionElement, filter: string) => boolean)\n    | string\n\n  /**\n   * How long a filter string needs to be at least to trigger the filter.\n   * Minimum length is 1 (following the standard pattern for input fields using\n   * `\"autocomplete\"` as they should support the user while typing).\n   * Used when `keyboard-behavior=\"filter\"` or `keyboard-behavior=\"autocomplete\"`.\n   */\n  @Prop() public filterMinLength: number = 3\n\n  /**\n   * Placeholder text for \"Type to filter...\".\n   */\n  @Prop() public filterInputPlaceholder: string = \"Type to filter...\"\n\n  /**\n   * Set this to false to declare the component as invalid and use the\n   * `validation-message` attribute to explain why.\n   */\n  @Prop() public valid?: boolean\n\n  /**\n   * Text that explains the validation status to the user.\n   */\n  @Prop() public validationMessage?: string\n\n  /**\n   * Marks the component as required (please note that this itself does not\n   * handle validation &mdash; use the `valid` and `validation-message` for\n   * that).\n   */\n  @Prop() public required: boolean = false\n\n  /**\n   * Allowed number of characters.\n   * Used when `keyboard-behavior=\"autocomplete\"`.\n   */\n  @Prop() public maxlength?: number\n\n  /**\n   * Focuses the input field as soon as it's rendered.\n   * Used when `keyboard-behavior=\"autocomplete\"`.\n   */\n  @Prop() public autofocus: boolean = false\n\n  /**\n   * Disable animations for testing.\n   * @private\n   */\n  @Prop() public animated: boolean = true\n\n  /**\n   * Emitted when the user changed the filter keyword while\n   * `keyboard-behavior=\"filter\"`.\n   */\n  @Event() public sdxfilter!: EventEmitter<{ keyword: string }>\n\n  @Watch(\"state\")\n  public stateChanged({}, prev: StateHandle<SelectState>) {\n    const state = this.state.get()\n    const prevState = prev.get()\n\n    if (state.selection !== prevState.selection) {\n      this.selectionChanged(state)\n    }\n\n    if (state.optionEls !== prevState.optionEls) {\n      this.optionElsChanged(state)\n    }\n\n    if (state.filter !== prevState.filter) {\n      this.filterChanged(state)\n    }\n\n    if (state.filterInputElValue !== prevState.filterInputElValue) {\n      this.filterInputElValueChanged(state)\n    }\n  }\n\n  @Watch(\"value\")\n  public valueChanged() {\n    if (!this.componentDidLoadComplete) {\n      return\n    }\n\n    // Update the filter keyword when \"autocomplete\" and stop doing anything else\n    if (isKeyboardBehavior(this.state.get(), \"autocomplete\")) {\n      const filter = this.value[0] || \"\"\n\n      if (!this.filterInputElValueChangedInProgress) {\n        this.store.dispatch({ type: \"SET_FILTER\", filter })\n\n        this.valueChangedInProgress = true\n        this.store.set(\"filterInputElValue\", filter)\n        this.valueChangedInProgress = false\n      }\n\n      this.updateHiddenFormInputEl()\n\n      this.invokeChangeCallback(this.value)\n\n      return\n    }\n\n    const { allValuesValid, validatedValues, optionEls } = this.getByValues(\n      this.value\n    )\n\n    if (!allValuesValid) {\n      this.value = validatedValues\n\n      return\n    }\n\n    // Update the selection\n    if (!this.selectionChangedInProgress) {\n      // Set selection\n      this.valueChangedInProgress = true\n      this.store.set(\"selection\", optionEls)\n      this.valueChangedInProgress = false\n    }\n\n    // Invoke callbacks\n    if (this.state.get().connected) {\n      this.invokeChangeCallback(this.value)\n      this.invokeSelectCallback(this.value)\n    }\n  }\n\n  @Watch(\"filterable\")\n  public filterableChanged() {\n    this.store.set(\"filterable\", this.filterable)\n  }\n\n  @Watch(\"filterInputPlaceholder\")\n  public filterInputPlaceholderChanged() {\n    this.store.set(\"filterInputElPlaceholder\", this.filterInputPlaceholder)\n  }\n\n  @Watch(\"filterMinLength\")\n  public filterMinLengthChanged() {\n    this.store.set(\"filterMinLength\", this.filterMinLength)\n  }\n\n  @Watch(\"noMatchesFoundLabel\")\n  public noMatchesFoundLabelChanged() {\n    this.store.set(\"noMatchesFoundLabel\", this.noMatchesFoundLabel)\n  }\n\n  @Watch(\"selectCallback\")\n  public selectCallbackChanged() {\n    this.setInvokeSelectCallback()\n  }\n\n  @Watch(\"changeCallback\")\n  public changeCallbackChanged() {\n    this.setInvokeChangeCallback()\n  }\n\n  @Watch(\"filterCallback\")\n  public filterCallbackChanged() {\n    this.setInvokeFilterCallback()\n  }\n\n  @Watch(\"focusCallback\")\n  public focusCallbackChanged() {\n    this.setInvokeFocusCallback()\n  }\n\n  @Watch(\"blurCallback\")\n  public blurCallbackChanged() {\n    this.setInvokeBlurCallback()\n  }\n\n  @Watch(\"placeholder\")\n  public placeholderChanged() {\n    this.store.set(\"placeholder\", this.placeholder)\n    this.resetFilter()\n  }\n\n  @Watch(\"name\")\n  public nameChanged() {\n    this.store.set(\"name\", this.name)\n    this.updateHiddenFormInputEl()\n  }\n\n  @Watch(\"filterFunction\")\n  public filterFunctionChanged() {\n    this.setFilterFunction()\n  }\n\n  @Watch(\"multiple\")\n  public multipleChanged() {\n    this.store.set(\"multiple\", this.multiple)\n  }\n\n  @Watch(\"required\")\n  public requiredChanged() {\n    this.store.set(\"required\", this.required)\n  }\n\n  @Watch(\"keyboardBehavior\")\n  public keyboardBehaviorChanged() {\n    this.store.set(\"keyboardBehavior\", this.keyboardBehavior)\n  }\n\n  @Watch(\"loading\")\n  public loadingChanged() {\n    this.store.set(\"loading\", this.loading)\n    this.showNoMatchesFoundIfNecessary()\n  }\n\n  /**\n   * Emitted when users press enter key or click on search button when\n   * `type=\"search\"` is set.\n   */\n  @Event() public sdxsearch!: EventEmitter\n\n  @Listen(\"keyup\", { target: \"window\" })\n  public onWindowKeyUp(e: KeyboardEvent) {\n    if (e.key === \"Tab\") {\n      this.isTabDown = false\n    }\n  }\n\n  @Listen(\"focus\")\n  public onFocus() {\n    // Only handle focus triggered by pressing the tab key\n    if (!this.isTabDown) {\n      return\n    }\n\n    this.focussed = true\n  }\n\n  @Listen(\"blur\")\n  public onBlur() {\n    // Only handle blur triggered by pressing the tab key\n    if (!this.isTabDown) {\n      return\n    }\n\n    this.close()\n  }\n\n  // { capture: true } to make sure it's executed before requestToClose() which\n  // needs this.focussed to be up to date\n  @Listen(\"click\", { target: \"window\", capture: true })\n  @Listen(\"touchend\", { target: \"window\", capture: true })\n  public onWindowClick(e: MouseEvent) {\n    this.focussed =\n      e.composedPath().includes(this.el) ||\n      e.composedPath().includes(this.state.get().listEl!)\n  }\n\n  @Listen(\"resize\", { target: \"window\" })\n  public async onWindowResize() {\n    const { display } = this.state.get()\n\n    if (display === \"closed\") {\n      return\n    }\n\n    const dialogDisplay = await this.dialogEl?.getDisplay()\n    const isInsideDialog = this.setIsInsideDialog()\n\n    if (!isInsideDialog && dialogDisplay === \"open\") {\n      this.close()\n      return\n    }\n\n    const currentAngle = getScreenOrientationAngle()\n    if (currentAngle !== this.lastScreenOrientationAngle) {\n      // close in case of an orientation change\n      this.lastScreenOrientationAngle = currentAngle\n      this.close()\n    } else {\n      // in case of a desktop browser just recalculate the position\n      this.positionListEl()\n    }\n  }\n\n  @Listen(\"keydown\", { target: \"window\" })\n  public onKeyDown(e: KeyboardEvent) {\n    if (e.key === \"Tab\") {\n      this.isTabDown = true\n    }\n\n    // Only react to key events if the component is focussed\n    if (!this.focussed) {\n      return\n    }\n\n    switch (e.key) {\n      // Open focussed select\n      case \" \":\n        // Only listen to \"space\" keydown if the input element (for filterable) is not focussed,\n        // otherwise the user wouldn't be able to type white spaces anymore.\n        if (!this.hasFilterInputElFocus()) {\n          e.preventDefault() // Prevent scrolling\n\n          // For single select, it's possible to select with space\n          if (this.isOpenOrOpening() && !this.multiple && this.focussedEl) {\n            this.focussedEl.click()\n          } else {\n            this.toggle()\n          }\n        }\n\n        break\n\n      // Select currently focussed element\n      case \"Enter\":\n        if (this.focussedEl) {\n          // Just act like the user has clicked on it\n          this.focussedEl.click()\n        }\n\n        break\n\n      // Focus previous element\n      case \"ArrowUp\":\n        e.preventDefault() // Prevent scrolling\n        this.setFocussedEl(\"previous\")\n\n        if (this.hasVisibleOptionEls()) {\n          this.open()\n        }\n\n        break\n\n      // Focus next element\n      case \"ArrowDown\":\n        e.preventDefault() // Prevent scrolling\n        this.setFocussedEl(\"next\")\n\n        if (this.hasVisibleOptionEls()) {\n          this.open()\n        }\n\n        break\n\n      default:\n        const isAlphanumericKey = e.key.length === 1\n\n        if (isAlphanumericKey) {\n          // Only focus by letter if not filterable\n          if (!this.isFilterable()) {\n            this.setFocussedElByFirstLetter(e.key)\n          }\n        }\n    }\n  }\n\n  /**\n   * Returns the current selection.\n   * @deprecated read the \"value\" prop instead.\n   */\n  @Method()\n  public async getSelection(): Promise<any[]> {\n    return this.value\n  }\n\n  /**\n   * Toggles the sdx-select.\n   */\n  @Method()\n  public toggle(): Promise<void> {\n    return new Promise((resolve) => {\n      const state = this.state.get()\n\n      // When \"autocomplete\" is set, only open the menu on a certain input field value length\n      if (isKeyboardBehavior(state, \"autocomplete\")) {\n        if (\n          isFilterLongEnough(state.filterInputElValue, this.filterMinLength)\n        ) {\n          this.open().then(resolve)\n        } else {\n          resolve()\n        }\n\n        return\n      }\n\n      if (this.isOpenOrOpening()) {\n        this.close().then(resolve)\n      } else if (this.isClosedOrClosing()) {\n        this.open().then(resolve)\n      } else {\n        resolve()\n      }\n    })\n  }\n\n  /**\n   * Opens the select.\n   */\n  @Method()\n  public open(): Promise<void> {\n    return new Promise((resolve) => {\n      const state = this.state.get()\n      const { listEl } = state\n\n      if (!listEl) {\n        return\n      }\n\n      // Only a closed select can be opened\n      if (!this.isClosedOrClosing()) {\n        resolve()\n        return\n      }\n\n      this.overlayOutletEl = getOverlayOutletEl()\n      this.scrollContainerEl = getScrollContainerEl(this.el)\n\n      // Check if the select is inside a scrollable element.\n      // If yes, append the options there to make sure they scroll and aren't\n      // detached from the wrapperEl.\n      if (this.scrollContainerEl) {\n        this.overlayOutletEl = this.scrollContainerEl\n      } else {\n        this.scrollContainerEl = document.documentElement\n      }\n\n      const isInsideDialog = this.setIsInsideDialog()\n\n      if (isInsideDialog) {\n        this.appendTo(\"dialogEl\")\n      } else {\n        // Make options overlap all other content\n        this.appendTo(\"overlayOutlet\")\n      }\n\n      // Set dimensions\n      this.positionListEl()\n\n      this.store.set(\"display\", \"opening\")\n\n      anime({\n        targets: listEl,\n        scaleY: 1,\n        opacity: 1,\n        scrollTop: 0, // ensure scrollbar position in chrome\n        duration: this.getAnimationDuration(),\n        easing: \"cubicBezier(0.550, 0.085, 0.320, 1)\",\n        complete: () => {\n          this.store.set(\"display\", \"open\")\n\n          if (listEl) {\n            listEl.style.transform = \"\"\n          }\n\n          resolve()\n        },\n      })\n    })\n  }\n\n  /**\n   * Closes the sdx-select.\n   */\n  @Method()\n  public close(): Promise<void> {\n    return new Promise(async (resolve) => {\n      const state = this.state.get()\n\n      if (state.display !== \"open\") {\n        resolve()\n        return\n      }\n\n      this.dialogEl?.close()\n      this.setFocussedEl(null)\n\n      // Shift focus from input field back to the sdx-select (if filterable).\n      // Only an opened Select should be filterable.\n      if (isKeyboardBehavior(state, \"filter\")) {\n        this.nonEditableInputEl!.doFocus()\n      }\n\n      this.store.set(\"display\", \"closing\")\n\n      anime({\n        targets: state.listEl,\n        scaleY: 0,\n        opacity: 0.2,\n        duration: this.getAnimationDuration(),\n        easing: \"cubicBezier(0.550, 0.085, 0.320, 1)\",\n        complete: () => {\n          if (isKeyboardBehavior(state, \"filter\")) {\n            this.nonEditableInputEl!.doFocus()\n          }\n\n          this.store.set(\"display\", \"closed\")\n\n          // Bring options back to the component\n          this.appendTo(\"component\")\n\n          state.listEl!.style.display = \"none\"\n\n          resolve()\n        },\n      })\n    })\n  }\n\n  /**\n   * Sets the focus on the input field when `keyboard-behavior=\"filter\"` or\n   * `keyboard-behavior=\"autocomplete\"`.\n   */\n  @Method()\n  public async doFocus() {\n    const { listEl } = this.state.get()\n    this.filterInputEl?.doFocus() || listEl?.doFocus()\n  }\n\n  /**\n   * @private\n   * Calls close(), but only when the component is allowed to be closed.\n   */\n  @Method()\n  public async requestToClose(\n    e: KeyboardEvent | MouseEvent | TouchEvent\n  ): Promise<void> {\n    const { listEl } = this.state.get()\n\n    if (!listEl) {\n      return\n    }\n\n    if (e instanceof KeyboardEvent) {\n      if (e.key === \"Escape\") {\n        this.close()\n      }\n\n      return\n    }\n\n    const didClickOnEl = e.composedPath().includes(this.el)\n    const didClickOnListEl = e.composedPath().includes(listEl)\n\n    if (didClickOnEl || didClickOnListEl) {\n      return\n    }\n\n    // Clicked somewhere else on window\n    this.close()\n  }\n\n  constructor() {\n    this.store = new StoreConnection(this, selectReducer, getInitialState(), [\n      \"selection\",\n      \"listEl\",\n      \"optionEls\",\n      \"optgroupEls\",\n      \"filter\",\n      \"filterInputElValue\",\n      \"directionX\",\n      \"directionY\",\n      \"display\",\n      \"isInsideDialog\",\n    ])\n\n    this.setInvokeSelectCallback()\n    this.setInvokeChangeCallback()\n    this.setInvokeFilterCallback()\n    this.setInvokeFocusCallback()\n    this.setInvokeBlurCallback()\n    this.setFilterFunction()\n\n    this.store.set(\"placeholder\", this.placeholder)\n    this.store.set(\"multiple\", this.multiple)\n    this.store.set(\"required\", this.required)\n    this.store.set(\"keyboardBehavior\", this.keyboardBehavior)\n    this.store.set(\n      \"animationDuration\",\n      this.animated ? this.animationDuration : 0\n    )\n    this.store.set(\"close\", this.close.bind(this))\n    this.store.set(\"filterable\", this.filterable)\n    this.store.set(\"filterMinLength\", this.filterMinLength)\n    this.store.set(\"noMatchesFoundLabel\", this.noMatchesFoundLabel)\n    this.store.set(\"filterInputElPlaceholder\", this.filterInputPlaceholder)\n    this.store.set(\"name\", this.name)\n    this.store.set(\"loading\", this.loading)\n    this.setIsInsideDialog()\n\n    this.store.flush()\n\n    this.maxAutocompleteOptions = bp(\"lg\")\n      ? Select.maxAutocompleteOptionsDesktop\n      : Select.maxAutocompleteOptionsMobile\n\n    this.updateHiddenFormInputEl()\n    visualViewport?.addEventListener(\"resize\", this.visualViewportResizeHandler)\n  }\n\n  public connectedCallback() {\n    this.store.set(\"connected\", true)\n\n    this.isChildOfSdxFilter = !!closest(this.el, \"sdx-filter\")\n\n    // The component is being reconnected\n    if (this.isReappending) {\n      this.store.set(\"reappending\", true)\n      this.isReappending = false\n    }\n  }\n\n  public disconnectedCallback() {\n    this.store.set(\"connected\", false)\n\n    // Know that a disconnection happened, maybe because the component was\n    // removed, cached or it's being appended to document.body.\n    const isStillInDocument = closest(this.el, document.documentElement)\n\n    if (isStillInDocument) {\n      this.isReappending = true\n    } else {\n      visualViewport?.removeEventListener(\n        \"resize\",\n        this.visualViewportResizeHandler\n      )\n    }\n\n    // Make sure the component is closed when removed from the DOM\n    this.close()\n  }\n\n  public componentWillLoad() {\n    if (this.state.get().listEl) {\n      this.hasConsumerProvidedListEl = true\n    }\n  }\n\n  public componentDidLoad() {\n    const { selection, listEl } = this.state.get()\n    this.lastScreenOrientationAngle = getScreenOrientationAngle()\n\n    // Now that all children are loaded, sort them now and from now on.\n    // Having them sorted from the very beginning makes long lists very slow\n    // on Chrome 97 and Safari 15 (but interestingly not on Firefox 95).\n    this.store.dispatch({ type: \"ACTIVATE_SORT\" })\n\n    // Initial selection:\n    // If there are options with the \"selected\" prop, use those.\n    // If not, check if there's a \"value\" and use that instead.\n    if (selection.length) {\n      const { validatedValues } = this.getByValues(\n        selection.map((el) => el.value)\n      )\n\n      this.value = validatedValues\n    } else if (this.value.length) {\n      // use \"value\", if any\n      const { allValuesValid, validatedValues, optionEls } = this.getByValues(\n        this.value\n      )\n\n      if (allValuesValid && validatedValues.length) {\n        this.store.set(\"selection\", optionEls)\n      }\n    } else {\n      // fall back by selecting first option\n      this.selectFirstOptionElIfNecessary()\n    }\n\n    // List element is initially closed\n    listEl!.style.display = \"none\"\n    listEl!.style.opacity = \".2\"\n    listEl!.style.transform = \"scaleY(0)\"\n\n    // Can't simply forward autocomplete={this.autocomplete} because sdx-input\n    // is a child of sdx-select and therefore not yet visible, even within its\n    // componentDidLoad(). Browsers don't allow focussing invisible elements.\n    // Hence this manual call:\n    if (this.autofocus) {\n      this.doFocus()\n    }\n\n    this.store.subscribe()\n\n    // All children are now ready\n    this.componentDidLoadComplete = true\n  }\n\n  public componentDidUpdate() {\n    if (this.optionElsDidUpdate) {\n      // Apply filter to dynamically added options.\n      // This has to happen after render() because the default filter function\n      // uses .textContent which doesn't exist before render() in Angular when\n      // using {{ text interpolation }}.\n      this.showNoMatchesFoundIfNecessary()\n\n      this.optionElsDidUpdate = false\n    }\n  }\n\n  private selectionChanged(state: SelectState) {\n    this.selectionChangedInProgress = true\n\n    this.selectFirstOptionElIfNecessary()\n\n    // Update state after possible first selection from above\n    state = this.state.get()\n\n    // Update the \"value\"\n    if (!this.valueChangedInProgress) {\n      const { validatedValues } = this.getByValues(\n        state.selection.map((el) => el.value)\n      )\n\n      this.value = validatedValues\n\n      if (state.userInteractionInProgress) {\n        dispatchEvent(this.el, Select.eventInput)\n\n        this.store.set(\"userInteractionInProgress\", false)\n      }\n    }\n\n    this.selectionChangedInProgress = false\n  }\n\n  private optionElsChanged(state: SelectState) {\n    this.optionElsDidUpdate = true\n\n    // If new options come in while the component is open, directly append them\n    // to the body\n    if (state.optionEls.length && this.isOpenOrOpening()) {\n      this.appendTo(\"overlayOutlet\")\n    }\n  }\n\n  private filterChanged(state: SelectState) {\n    this.showNoMatchesFoundIfNecessary()\n\n    if (isKeyboardBehavior(state, \"filter\")) {\n      this.invokeFilterCallback(state.filter)\n      this.sdxfilter.emit({ keyword: state.filter })\n    }\n  }\n\n  private filterInputElValueChanged(state: SelectState) {\n    this.filterInputElValueChangedInProgress = true\n\n    if (isKeyboardBehavior(state, \"autocomplete\")) {\n      this.value = [state.filterInputElValue]\n\n      if (state.userInteractionInProgress) {\n        dispatchEvent(this.el, Select.eventInput)\n      }\n    }\n\n    this.filterInputElValueChangedInProgress = false\n  }\n\n  // Appends all options to the body to guarantee visibility (as overlay)\n  private async appendTo(target: \"overlayOutlet\" | \"component\" | \"dialogEl\") {\n    const { display, listEl } = this.state.get()\n\n    this.store.set(\"reappending\", true)\n\n    switch (target) {\n      case \"overlayOutlet\":\n        // When the component is already open, the list element is already\n        // appended to the body. If it's appended twice, the filter input field\n        // loses focus.\n        if (display === \"closed\") {\n          appendToOverlayOutlet(listEl!, this.overlayOutletEl!, this.el)\n        }\n\n        if (!this.hasConsumerProvidedListEl) {\n          listEl!.append(...this.getDirectSlotEls())\n        }\n\n        break\n\n      case \"dialogEl\":\n        appendToOverlayOutlet(listEl!, this.dialogContentEl!, this.el)\n\n        if (!this.hasConsumerProvidedListEl) {\n          listEl!.append(...this.getDirectSlotEls())\n        }\n\n        // store set reappending=false after all options have been reappended once\n        this.store.set(\"reappending\", true)\n        await this.dialogEl?.open()\n\n        break\n\n      default:\n        // \"component\"\n        if (this.hasConsumerProvidedListEl) {\n          appendToOverlayOutlet(listEl!, this.el, this.el)\n        } else {\n          this.el.append(...this.getDirectSlotEls())\n          appendToOverlayOutlet(listEl!, this.wrapperEl!, this.el)\n        }\n    }\n\n    this.store.set(\"reappending\", false)\n  }\n\n  private updateHiddenFormInputEl(): void {\n    if (!isKeyboardBehavior(this.state.get(), \"autocomplete\")) {\n      return\n    }\n\n    if (!this.lightDOMHiddenFormInputEl) {\n      this.lightDOMHiddenFormInputEl = document.createElement(\"input\")\n      this.lightDOMHiddenFormInputEl.type = \"hidden\"\n      this.el.append(this.lightDOMHiddenFormInputEl)\n    }\n\n    // Clean up properties added previously in case they've changed\n    this.lightDOMHiddenFormInputEl.removeAttribute(\"name\")\n    this.lightDOMHiddenFormInputEl.removeAttribute(\"value\")\n\n    if (this.name) {\n      this.lightDOMHiddenFormInputEl.name = this.name\n      this.lightDOMHiddenFormInputEl.value = this.value[0] || \"\"\n    }\n  }\n\n  // Resets the whole filter system\n  private resetFilter(): void {\n    this.resetFilterInputEl()\n    this.store.dispatch({ type: \"SET_FILTER\", filter: \"\" })\n  }\n\n  // Parses and injects the \"filter-function\" prop into the store\n  private setFilterFunction(): void {\n    this.parsedFilterFunction = this.optionElMatchesFilter\n  }\n\n  // Write the current selection into the filter input field\n  private resetFilterInputEl() {\n    if (!this.isFilterable()) {\n      return\n    }\n\n    const state = this.state.get()\n    let filterInputElValue = \"\"\n\n    // For \"autocomplete\", the filter input field should contain the selected value\n    if (isKeyboardBehavior(state, \"autocomplete\")) {\n      filterInputElValue = getFormattedSelection(state.selection)\n    }\n\n    this.store.set(\"filterInputElValue\", filterInputElValue)\n  }\n\n  private positionListEl(): void {\n    const { listEl, isInsideDialog } = this.state.get()\n\n    if (\n      !(this.componentEl && this.wrapperEl && this.scrollContainerEl && listEl)\n    ) {\n      return\n    }\n\n    if (isInsideDialog) {\n      // due to the specificity style must be set here\n      listEl.style.display = \"block\"\n      listEl.style.minWidth = \"\"\n      listEl.style.maxHeight = \"\"\n      listEl.style.inset = \"\"\n      listEl.style.transformOrigin = \"\"\n\n      // stop calculating position because listEl is appended to dialogEl\n      return\n    }\n\n    const wrapperElRect = this.wrapperEl.getBoundingClientRect()\n\n    let spaceTowards = {\n      bottom: document.documentElement.clientHeight - wrapperElRect.bottom,\n      left: wrapperElRect.left,\n      right: document.documentElement.clientWidth - wrapperElRect.right,\n      top: wrapperElRect.top,\n    }\n\n    // Height calculation\n    const maxHeightFromProp = this.getMaxHeight()\n    listEl.style.maxHeight = maxHeightFromProp || \"none\"\n\n    let scrollContainerElRect = {\n      bottom: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n    }\n\n    // If the overlay is inside an offset parent, include all its spacings\n    // in the calculation.\n    if (this.scrollContainerEl !== document.documentElement) {\n      scrollContainerElRect = this.scrollContainerEl.getBoundingClientRect()\n\n      // Subtract wrapperElRect from scrollContainerElRect\n      spaceTowards = {\n        bottom: scrollContainerElRect.bottom - wrapperElRect.bottom,\n        left: wrapperElRect.left - scrollContainerElRect.left,\n        right: scrollContainerElRect.right - wrapperElRect.right,\n        top: wrapperElRect.top - scrollContainerElRect.top,\n      }\n    }\n\n    // Show the listEl to take measurements\n    listEl.style.display = \"block\"\n\n    let listElWidth = listEl.clientWidth\n    let listElHeight = listEl.clientHeight\n    let maxHeight = listEl.style.maxHeight\n\n    // For \"autocomplete\", clientHeight is always 0, because it doesn't display\n    // any options initially. Since that will falsify the positioning\n    // calculation, act like the fully allowed number of options is displayed.\n    if (isKeyboardBehavior(this.state.get(), \"autocomplete\")) {\n      listElHeight = this.maxAutocompleteOptions * Select.selectHeight\n    }\n\n    let directionX: DirectionX\n    let directionY: DirectionY\n\n    if (spaceTowards.right - Select.minSpaceToWindow >= listElWidth) {\n      // enough space towards right\n      directionX = \"right\"\n    } else if (spaceTowards.left - Select.minSpaceToWindow >= listElWidth) {\n      // enough space towards left\n      directionX = \"left\"\n    } else if (spaceTowards.left > spaceTowards.right) {\n      // not enough space, open towards left\n      directionX = \"left\"\n    } else {\n      // not enough space, open towards right\n      directionX = \"right\"\n    }\n\n    const heightOfTwoOptions = Select.selectHeight * 2\n\n    if (\n      spaceTowards.bottom - Select.minSpaceToWindow - heightOfTwoOptions >=\n      listElHeight\n    ) {\n      // enough space towards bottom\n      maxHeight = maxHeightFromProp\n        ? maxHeight\n        : `${spaceTowards.bottom - Select.minSpaceToWindow}px`\n      directionY = \"bottom\"\n    } else if (\n      spaceTowards.top - Select.minSpaceToWindow - heightOfTwoOptions >=\n      listElHeight\n    ) {\n      // enough space towards top\n      maxHeight = maxHeightFromProp\n        ? maxHeight\n        : `${spaceTowards.top - Select.minSpaceToWindow}px`\n      directionY = \"top\"\n    } else if (spaceTowards.top > spaceTowards.bottom) {\n      // not enough space, open towards top\n      maxHeight = `${spaceTowards.top - Select.minSpaceToWindow}px`\n      directionY = \"top\"\n    } else {\n      // not enough space, open towards bottom\n      maxHeight = `${spaceTowards.bottom - Select.minSpaceToWindow}px`\n      directionY = \"bottom\"\n    }\n\n    // There should always be a max-height, because even though it has enough\n    // space at the time being, it might be that it grows dynamically while\n    // being opened, for example by clearing a filter (which will show all\n    // options immediately).\n    listEl.style.maxHeight = maxHeight\n\n    // List should never be smaller than its wrapper\n    listEl.style.minWidth = `${wrapperElRect.width}px`\n\n    if (directionX === \"right\") {\n      listEl.style.right = \"auto\"\n      listEl.style.left = `${\n        getScrollTopLeft(this.scrollContainerEl).scrollLeft -\n        scrollContainerElRect.left +\n        wrapperElRect.left\n      }px`\n    } else {\n      // \"left\"\n      listEl.style.left = \"auto\"\n      listEl.style.right = `${\n        this.scrollContainerEl.clientWidth -\n        getScrollTopLeft(this.scrollContainerEl).scrollLeft +\n        scrollContainerElRect.left -\n        wrapperElRect.right\n      }px`\n    }\n\n    if (directionY === \"bottom\") {\n      listEl.style.transformOrigin = \"50% 0\"\n      listEl.style.bottom = \"auto\"\n      listEl.style.top = `${\n        getScrollTopLeft(this.scrollContainerEl).scrollTop -\n        scrollContainerElRect.top +\n        wrapperElRect.bottom -\n        1\n      }px`\n      // -1px = border overlap\n    } else {\n      // \"top\"\n      listEl.style.transformOrigin = \"0 100%\"\n      listEl.style.top = \"auto\"\n      listEl.style.bottom = `${\n        this.scrollContainerEl.clientHeight -\n        getScrollTopLeft(this.scrollContainerEl).scrollTop +\n        scrollContainerElRect.top -\n        wrapperElRect.top -\n        1\n      }px`\n      // -1px = border overlap\n    }\n\n    // Propagate newly calculated direction\n    this.store.set(\"directionX\", directionX)\n    this.store.set(\"directionY\", directionY)\n  }\n\n  // If no \"filter-function\" is present, fall back to this\n  private defaultFilterFunction(\n    optionEl: HTMLSdxSelectOptionElement,\n    filter: string\n  ): boolean {\n    // Skip placeholder and empty options\n    if ((filter && optionEl.placeholder) || !optionEl.textContent) {\n      return false\n    }\n\n    return optionEl.textContent.toLowerCase().indexOf(filter.toLowerCase()) > -1\n  }\n\n  /**\n   * Returns true if an option element matches the filter (e.g. in \"ca\" in\n   * \"Car\").\n   * @param el The option to be tested.\n   * @param filter The Filter to be tested.\n   */\n  private optionElMatchesFilter(\n    el: HTMLSdxSelectOptionElement,\n    filter: string\n  ): boolean {\n    let filterFunction = this.defaultFilterFunction\n\n    // If a \"filter-function\" prop has been passed, use this instead\n    if (this.filterFunction) {\n      filterFunction = parseFunction(this.filterFunction) as () => boolean\n    }\n\n    let match = filterFunction(el, filter)\n\n    // When \"autocomplete\", all options should be hidden if there's no filter,\n    // while when \"filter\", all options should be shown if there's no filter.\n    if (isKeyboardBehavior(this.state.get(), \"autocomplete\") && !filter) {\n      match = false\n    }\n\n    return match\n  }\n\n  private setFocussedEl(\n    which: HTMLSdxSelectOptionElement | null | \"previous\" | \"next\"\n  ): void {\n    const { optionEls, selection } = this.state.get()\n\n    // First, unfocus all\n    for (let i = 0; i < optionEls.length; i++) {\n      const optionEl = optionEls[i]\n\n      optionEl.classList.remove(\"focus\")\n    }\n\n    // If no element is to be selected, clear and abort\n    if (which === null) {\n      delete this.focussedEl\n      return\n    }\n\n    if (which === \"previous\" || which === \"next\") {\n      const lastSelectedEl = selection[selection.length - 1]\n\n      // If there's no currently focussed element, start from the last selected element\n      let focussedEl = this.focussedEl || lastSelectedEl\n\n      // If there's a focussed element, but is hidden, start from the first option\n      if (focussedEl?.style.display === \"none\") {\n        focussedEl = optionEls[0]\n      }\n\n      if (which === \"previous\") {\n        let prevEl = getPreviousFromList(optionEls, focussedEl)\n        let count = 0\n\n        while (\n          prevEl !== focussedEl &&\n          (prevEl.disabled || prevEl.style.display === \"none\") &&\n          count < optionEls.length\n        ) {\n          prevEl = getPreviousFromList(optionEls, prevEl)\n          count += 1\n        }\n\n        this.focussedEl = prevEl\n      } else {\n        // \"next\"\n        let nextEl = getNextFromList(optionEls, focussedEl)\n        let count = 0\n\n        while (\n          nextEl !== focussedEl &&\n          (nextEl.disabled || nextEl.style.display === \"none\") &&\n          count < optionEls.length\n        ) {\n          nextEl = getNextFromList(optionEls, nextEl)\n          count += 1\n        }\n\n        this.focussedEl = nextEl\n      }\n    } else {\n      // \"which\" is an element\n      this.focussedEl = which\n    }\n\n    if (this.focussedEl) {\n      this.focussedEl.classList.add(\"focus\")\n      this.scrollToOption(this.focussedEl)\n    }\n  }\n\n  /**\n   * Scrolls the list the way that an option is visible in the center.\n   */\n  private scrollToOption(option: HTMLSdxSelectOptionElement) {\n    const parent = this.state.get().listEl!\n    const optionRect = option.getBoundingClientRect()\n    const parentRect = parent.getBoundingClientRect()\n    const isFullyVisible =\n      optionRect.top >= parentRect.top &&\n      optionRect.bottom <= parentRect.top + parent.clientHeight\n\n    if (!isFullyVisible) {\n      parent.scrollTop = optionRect.top + parent.scrollTop - parentRect.top\n    }\n  }\n\n  /**\n   * Returns all options starting with a certain letter.\n   * @param letter Key value to look for.\n   */\n  private getOptionElsByFirstLetter(\n    letter: string\n  ): HTMLSdxSelectOptionElement[] {\n    const { optionEls } = this.state.get()\n    const results: HTMLSdxSelectOptionElement[] = []\n\n    for (let i = 0; i < optionEls.length; i++) {\n      const option = optionEls[i]\n\n      if (\n        option.textContent?.toLowerCase().charAt(0) === letter.toLowerCase()\n      ) {\n        results.push(option)\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Sets the focussed option starting by a given letter.\n   * @param letter Key value to look for.\n   */\n  private setFocussedElByFirstLetter(letter: string): void {\n    const optionsByFirstLetter = this.getOptionElsByFirstLetter(letter)\n\n    if (optionsByFirstLetter.length) {\n      let startIndex = 0\n\n      if (this.focussedEl) {\n        const focussedElIndex = optionsByFirstLetter.indexOf(this.focussedEl)\n\n        if (focussedElIndex > -1) {\n          startIndex = focussedElIndex\n        }\n      }\n\n      let option: HTMLSdxSelectOptionElement | null =\n        optionsByFirstLetter[startIndex]\n\n      if (option.disabled || option === this.focussedEl) {\n        for (let i = 0; i < optionsByFirstLetter.length; i++) {\n          option = getNextFromList(\n            optionsByFirstLetter,\n            optionsByFirstLetter[startIndex]\n          )\n\n          if (option.disabled) {\n            option = null\n          } else {\n            break\n          }\n\n          // Look behind\n          if (startIndex < optionsByFirstLetter.length) {\n            startIndex += 1\n          } else {\n            startIndex = 0\n          }\n        }\n      }\n\n      if (option) {\n        this.setFocussedEl(option)\n      }\n    }\n  }\n\n  private setInvokeSelectCallback(): void {\n    this.invokeSelectCallback = parseFunction(this.selectCallback)\n  }\n\n  private setInvokeChangeCallback(): void {\n    this.invokeChangeCallback = parseFunction(this.changeCallback)\n  }\n\n  private setInvokeFilterCallback(): void {\n    this.invokeFilterCallback = parseFunction(this.filterCallback)\n  }\n\n  private setInvokeFocusCallback(): void {\n    this.invokeFocusCallback = parseFunction(this.focusCallback)\n  }\n\n  private setInvokeBlurCallback(): void {\n    this.invokeBlurCallback = parseFunction(this.blurCallback)\n  }\n\n  /**\n   * Checks if an array of values is valid and create a valid version of it.\n   * For convenience, all options matching the values will also be returned.\n   */\n  private getByValues(values: any[]): {\n    allValuesValid: boolean\n    validatedValues: any[]\n    optionEls: HTMLSdxSelectOptionElement[]\n  } {\n    if (Array.isArray(values)) {\n      if (!values.length) {\n        // Nothing to do, don't replace [] with [] because of change detection\n        return { allValuesValid: true, validatedValues: values, optionEls: [] }\n      }\n\n      // Filter out undefined values\n      const definedValues = values.filter((value) => value !== undefined)\n\n      if (!definedValues.length) {\n        // Either only undefined values or completely empty\n        return { allValuesValid: false, validatedValues: [], optionEls: [] }\n      }\n\n      const validatedValues: any[] = []\n      const foundOptionEls: HTMLSdxSelectOptionElement[] = []\n      const { optionEls } = this.state.get()\n\n      let isValid = true\n\n      // Check if values exist in the options\n      for (let i = 0; i < definedValues.length; i++) {\n        const value = definedValues[i]\n        const foundOptionEl = optionEls.find((el) => el.value === value)\n\n        if (foundOptionEl) {\n          if (this.multiple || (!this.multiple && i === 0)) {\n            foundOptionEls.push(foundOptionEl)\n            validatedValues.push(foundOptionEl.value)\n          } else {\n            // Single select should only respect one value\n            isValid = false\n          }\n        }\n      }\n\n      if (validatedValues.length === 0) {\n        // no values found\n        return {\n          allValuesValid: false,\n          validatedValues,\n          optionEls: foundOptionEls,\n        }\n      }\n\n      return {\n        allValuesValid: isValid,\n        validatedValues,\n        optionEls: foundOptionEls,\n      }\n    }\n\n    // All non-array types will be reset (to an empty array)\n    return { allValuesValid: false, validatedValues: [], optionEls: [] }\n  }\n\n  // If there are options, but no selection, and no placeholder,\n  // fall back by selecting first option\n  private selectFirstOptionElIfNecessary(): void {\n    const { optionEls, selection, placeholder, multiple, keyboardBehavior } =\n      this.state.get()\n\n    if (\n      optionEls.length &&\n      !selection.length &&\n      !placeholder &&\n      !multiple &&\n      keyboardBehavior !== \"autocomplete\"\n    ) {\n      const optionsNotDisabled = optionEls.filter((option) => !option.disabled)\n\n      if (optionsNotDisabled.length === 0) {\n        return\n      }\n\n      this.store.set(\"selection\", [optionsNotDisabled[0]])\n    }\n  }\n\n  private showNoMatchesFoundIfNecessary(): void {\n    const { optionEls, optgroupEls, filter, selection } = this.state.get()\n    let matches = 0\n\n    optionEls.forEach((optionEl) => {\n      let display\n\n      if (this.parsedFilterFunction(optionEl, filter)) {\n        matches += 1\n        display = \"\"\n      } else {\n        display = \"none\"\n      }\n\n      // For \"autocomplete\", display only a certain number of option elements (for UX)\n      if (isKeyboardBehavior(this.state.get(), \"autocomplete\")) {\n        if (matches > this.maxAutocompleteOptions) {\n          display = \"none\"\n        }\n      }\n\n      optionEl.style.display = display\n    })\n\n    optgroupEls.forEach((optgroupEl) => {\n      let match = false\n\n      for (let optionEl of optgroupEl.querySelectorAll(\"sdx-select-option\")) {\n        if (optionEl.style.display === \"\") {\n          match = true\n          break\n        }\n      }\n\n      optgroupEl.style.display = match ? \"\" : \"none\"\n    })\n\n    let noMatchesFound =\n      isValidFilter(filter, selection, this.filterMinLength) &&\n      matches === 0 &&\n      !this.loading\n\n    this.store.set(\"noMatchesFound\", noMatchesFound)\n  }\n\n  // Returns optionEls and optgroupEls directly descending from <sdx-select>,\n  // sorted by their appearance in the DOM tree to avoid having all options\n  // first and all optgroups last.\n  private getDirectSlotEls() {\n    const { optionEls, optgroupEls } = this.state.get()\n\n    return [\n      ...optionEls.filter(\n        (\n          el // skip placeholder and options within optgroups\n        ) => !el.placeholder && !closest(el, \"sdx-select-optgroup\")\n      ),\n      ...optgroupEls,\n    ].sort(sortByAppearanceInDomTree)\n  }\n\n  private onHeaderClick(e: MouseEvent): void {\n    const targetEl = e.target as HTMLElement\n    const didClickOnSdxInputEl = !!closest(targetEl, this.filterInputEl!)\n\n    if (\n      this.isFilterable() &&\n      this.isOpenOrOpening() &&\n      didClickOnSdxInputEl &&\n      !this.hadFilterInputElFocus\n    ) {\n      // Don't toggle when the user clicks on the filter input field\n    } else {\n      this.toggle()\n    }\n\n    this.hadFilterInputElFocus = this.hasFilterInputElFocus()\n  }\n\n  private onAutocompleteFocus(): void {\n    this.invokeFocusCallback()\n  }\n\n  private onAutocompleteBlur(): void {\n    this.invokeBlurCallback()\n  }\n\n  private onAutocompleteInput(e: Event): void {\n    const value = (e.target as HTMLSdxInputElement).value\n\n    this.store.set(\"filterInputElValue\", value)\n    this.store.dispatch({ type: \"SET_FILTER\", filter: value })\n\n    // Debounced\n    if (this.resizeTimer) {\n      clearTimeout(this.resizeTimer)\n    }\n\n    this.resizeTimer = setTimeout(() => {\n      if (isFilterLongEnough(value, this.filterMinLength)) {\n        this.open()\n      } else {\n        this.close()\n      }\n    }, this.state.get().animationDuration) // can be controlled using animated=\"false\"\n  }\n\n  /**\n   * True if this sdx-select is filterable using a filter input field.\n   */\n  private isFilterable(): boolean {\n    const state = this.state.get()\n\n    return (\n      isKeyboardBehavior(state, \"filter\") ||\n      isKeyboardBehavior(state, \"autocomplete\")\n    )\n  }\n\n  private hasVisibleOptionEls(): boolean {\n    return this.state\n      .get()\n      .optionEls.some((optioneEl) => optioneEl.style.display !== \"none\")\n  }\n\n  private isOpenOrOpening(): boolean {\n    const { display } = this.state.get()\n    return display === \"open\" || display === \"opening\"\n  }\n\n  private isClosedOrClosing(): boolean {\n    const { display } = this.state.get()\n    return display === \"closed\" || display === \"closing\"\n  }\n\n  private isListOverlapping(): boolean {\n    const { listEl } = this.state.get()\n\n    if (!(listEl && this.wrapperEl)) {\n      return false\n    }\n\n    return listEl.clientWidth > this.wrapperEl.clientWidth\n  }\n\n  /**\n   * Normalizes max-height prop, e.g.:\n   * 200 => \"200px\"\n   * \"50vh\" => \"50vh\"\n   */\n  private getMaxHeight(): string | undefined {\n    // No max-height prop given\n    if (!this.maxHeight) {\n      return\n    }\n\n    // If number, add \"px\"\n    if (Number(this.maxHeight)) {\n      return `${this.maxHeight}px`\n    }\n\n    // Unit is already given\n    return String(this.maxHeight) // TS bug? String() shouldn't be needed because of above Number()\n  }\n\n  /**\n   * Decide if element is inside a dialog and set state accordingly.\n   * @returns The updated value of isInsideDialog.\n   */\n  private setIsInsideDialog() {\n    const isInsideDialog =\n      (!bp(\"sm\") || isTouchscreen()) && this.keyboardBehavior !== \"autocomplete\"\n\n    this.store.set(\"isInsideDialog\", isInsideDialog)\n\n    return isInsideDialog\n  }\n\n  private hasFilterInputElFocus() {\n    if (isKeyboardBehavior(this.state.get(), \"autocomplete\")) {\n      return this.filterInputEl === this.el.shadowRoot!.activeElement\n    } else {\n      return !!this.state.get().listEl?.shadowRoot!.activeElement\n    }\n  }\n\n  private getDefaultInputFieldProps() {\n    return {\n      disabled: this.disabled,\n      valid: this.valid,\n      srHint: `${this.label} ${this.srHint} ${this.validationMessage || \"\"}`,\n      required: this.required,\n      role: \"combobox\",\n      ariaExpanded: this.state.get().display === \"open\",\n    }\n  }\n\n  private getComponentClassNames() {\n    const { display, directionX, directionY } = this.state.get()\n\n    return {\n      component: true,\n      focus: this.focussed,\n      loading: this.loading,\n      disabled: this.disabled,\n      invalid: this.valid === false,\n      filterable: this.isFilterable(),\n      autocomplete: isKeyboardBehavior(this.state.get(), \"autocomplete\"),\n      \"is-list-overlapping\": this.isListOverlapping(),\n      [this.backgroundTheme]: true,\n      [getAppearance(this.el)]: true,\n      [display]: true,\n      [directionX]: true,\n      [directionY]: true,\n    }\n  }\n\n  private getLabelClassNames() {\n    return {\n      label: true,\n      [getAppearance(this.el)]: true,\n    }\n  }\n\n  private getDefaultInputFieldStyle() {\n    const state = this.state.get()\n    const { isInsideDialog } = state\n\n    const notClosed = state.display !== \"closed\"\n    const openTowardsTop = state.directionY === \"top\"\n    const openTowardsBottom = state.directionY === \"bottom\"\n    const notClosedTowardsTop = notClosed && openTowardsTop && !isInsideDialog\n    const notClosedTowardsBottom =\n      notClosed && openTowardsBottom && !isInsideDialog\n\n    // Provide enough space for chevron or loading spinner\n    const paddingRight =\n      isKeyboardBehavior(state, \"autocomplete\") && !this.loading\n        ? undefined\n        : \"40px\"\n\n    return {\n      paddingRight,\n      borderTopLeftRadius: notClosedTowardsTop ? \"0\" : \"\",\n      borderTopRightRadius: notClosedTowardsTop ? \"0\" : \"\",\n      borderBottomLeftRadius: notClosedTowardsBottom ? \"0\" : \"\",\n      borderBottomRightRadius: notClosedTowardsBottom ? \"0\" : \"\",\n    }\n  }\n\n  private getAnimationDuration(): number {\n    const { isInsideDialog, animationDuration } = this.state.get()\n    return isInsideDialog ? 0 : animationDuration\n  }\n\n  public render() {\n    const state = this.state.get()\n    const appearance = getAppearance(this.el)\n\n    return (\n      <Host aria-expanded={(state.display === \"open\").toString()}>\n        <div\n          class={this.getComponentClassNames()}\n          ref={(el) => (this.componentEl = el)}\n        >\n          {!this.isChildOfSdxFilter && this.label && (\n            // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions\n            <label\n              class={this.getLabelClassNames()}\n              onClick={() => this.toggle()}\n            >\n              {this.label}\n              {this.required && <span aria-hidden=\"true\">&nbsp;*</span>}\n            </label>\n          )}\n\n          <div class=\"wrapper\" ref={(el) => (this.wrapperEl = el)}>\n            <div class=\"header-wrapper\">\n              {/* eslint-disable-next-line jsx-a11y/no-static-element-interactions */}\n              <div class=\"header\" onClick={(e) => this.onHeaderClick(e)}>\n                <div class=\"selection\">\n                  {isKeyboardBehavior(state, \"autocomplete\") ? (\n                    <sdx-input\n                      {...this.getDefaultInputFieldProps()}\n                      class=\"autocomplete-input\"\n                      value={state.filterInputElValue}\n                      placeholder={this.placeholder}\n                      maxlength={this.maxlength}\n                      editable={true}\n                      type={this.loading ? undefined : this.type}\n                      inputStyle={this.getDefaultInputFieldStyle()}\n                      onInput={(e) => this.onAutocompleteInput(e)}\n                      onFocus={() => this.onAutocompleteFocus()}\n                      onBlur={() => this.onAutocompleteBlur()}\n                      aria-autocomplete=\"list\"\n                      ref={(el) => (this.filterInputEl = el)}\n                    />\n                  ) : (\n                    <sdx-input\n                      {...this.getDefaultInputFieldProps()}\n                      value={\n                        (this.isChildOfSdxFilter && this.label) ||\n                        getFormattedSelection(state.selection)\n                      }\n                      placeholder={this.placeholder}\n                      badge={\n                        this.multiple && state.selection.length\n                          ? state.selection.length.toString()\n                          : undefined\n                      }\n                      ref={(el) =>\n                        (this.nonEditableInputEl = el as HTMLSdxInputElement)\n                      }\n                      editable={false}\n                      valid={this.valid}\n                      inputStyle={{\n                        ...this.getDefaultInputFieldStyle(),\n                        borderColor: this.isOpenOrOpening()\n                          ? appearance === \"sdx--light-theme\"\n                            ? \"#086adb\" // $color-int-blue\n                            : \"#4294FF\" // $color-blue-int-3-dark-theme\n                          : \"\",\n                        color: this.isOpenOrOpening()\n                          ? appearance === \"sdx--light-theme\"\n                            ? \"#1781e3\" // $color-azure\n                            : \"#4294FF\" // $color-blue-int-3-dark-theme\n                          : \"\",\n                      }}\n                    />\n                  )}\n                </div>\n\n                {/*\n                  Don't show the thumb when \"autocomplete\" is set, because it should\n                  look like an input field (except for when \"loading\" is set)\n                */}\n                {(!isKeyboardBehavior(state, \"autocomplete\") ||\n                  this.loading) && (\n                  <div class=\"thumb\" aria-live=\"polite\">\n                    {this.loading ? (\n                      <sdx-loading-spinner\n                        srHint={this.srHint ? this.srHint : undefined}\n                        strokeInherit\n                      />\n                    ) : (\n                      <div class=\"icon\"></div>\n                    )}\n                  </div>\n                )}\n              </div>\n            </div>\n\n            {this.hasConsumerProvidedListEl ? (\n              <slot />\n            ) : (\n              <sdx-select-list>\n                <slot />\n              </sdx-select-list>\n            )}\n          </div>\n\n          {this.validationMessage && (\n            <sdx-validation-message\n              validationMessage={this.validationMessage}\n            />\n          )}\n        </div>\n\n        <sdx-dialog\n          ref={(el) => (this.dialogEl = el)}\n          label={this.label}\n          type=\"closable-modal\"\n          animated={this.animated}\n          onSdxdisplaychange={(e) => {\n            if (e.detail?.display === \"closing\") {\n              // needed because closing the dialog triggers disconnect\n              // of sdx-select-option\n              this.store.set(\"reappending\", true)\n            }\n\n            if (e.detail?.display === \"closed\") {\n              this.close()\n            }\n          }}\n        >\n          <sdx-dialog-content\n            fixedHeight={isKeyboardBehavior(state, \"filter\")}\n            ref={(el) => (this.dialogContentEl = el)}\n          />\n        </sdx-dialog>\n      </Host>\n    )\n  }\n}\n",":host {\n  @include scroll-y;\n  position: absolute;\n  backface-visibility: hidden; // ensure scrolling in Chrome when sdx-select is inside a vertical scrollbar\n  background: $color-white;\n  z-index: $zindex-topmost;\n  border-radius: $border-radius-medium;\n}\n\n:host(:not(.inside-dialog)) {\n  box-shadow: 0 0 4px 0 rgba($color-gray, 0.1),\n    inset 0 0 0 1px $color-gray-tint-6;\n\n  .filter-input-wrapper {\n    padding: $baseline;\n  }\n}\n\n:host(.inside-dialog) {\n  position: unset;\n  margin-top: -14px; // Fine adjustment\n\n  .filter-input-wrapper {\n    padding-bottom: $baseline;\n  }\n}\n\n:host(:focus) {\n  outline: none;\n}\n\n// Open/opening towards top\n:host(:not(.inside-dialog).open.top),\n:host(:not(.inside-dialog).opening.top) {\n  border-top: $border-width solid $color-gray-tint-8;\n\n  .component {\n    .filter-input-wrapper {\n      border-bottom: $border-width solid $color-gray-tint-6;\n    }\n  }\n}\n\n:host(:not(.inside-dialog).open.bottom),\n:host(:not(.inside-dialog).opening.bottom) {\n  border-bottom: $border-width solid $color-gray-tint-8;\n}\n\n// Open/opening/closing towards bottom\n:host(.bottom) {\n  border-radius: 0 0 $border-radius-medium $border-radius-medium;\n}\n\n// Open/opening/closing towards top\n:host(.top) {\n  border-radius: $border-radius-medium $border-radius-medium 0 0;\n}\n\n:host(.is-list-overlapping.bottom.right) {\n  border-top-right-radius: $border-radius-medium;\n}\n\n:host(.is-list-overlapping.bottom.left) {\n  border-top-left-radius: $border-radius-medium;\n}\n\n:host(.is-list-overlapping.top.right) {\n  border-bottom-right-radius: $border-radius-medium;\n}\n\n:host(.is-list-overlapping.top.left) {\n  border-bottom-left-radius: $border-radius-medium;\n}\n\n.component {\n  .no-matches-found {\n    height: $select-height;\n    display: flex;\n    align-items: center;\n    padding: 0 $baseline;\n    color: $color-int-orange;\n  }\n}\n\n:host(.sdx--dark-theme) {\n  background: $color-dusk-tint-2-dark-theme;\n  box-shadow: 0 0 4px 0 rgba($color-int-blue2-dark-theme, 0.1),\n    inset 0 0 0 1px $color-int-blue2-dark-theme;\n}\n\n:host(.sdx--dark-theme.inside-dialog) {\n  background: transparent;\n  box-shadow: unset;\n}\n\n// Open/opening towards top\n:host(.open.top.sdx--dark-theme),\n:host(.opening.top.sdx--dark-theme) {\n  border-top-color: $color-int-blue2-dark-theme;\n\n  .component {\n    .filter-input-wrapper {\n      border-bottom-color: $color-gray-tint-7-dark-theme;\n    }\n  }\n}\n\n:host(.open.bottom.sdx--dark-theme),\n:host(.opening.bottom.sdx--dark-theme) {\n  border-bottom-color: $color-int-blue2-dark-theme;\n}\n\n.component.sdx--dark-theme {\n  .no-matches-found {\n    color: $color-int-orange2-dark-theme;\n  }\n}\n","import {\n  Component,\n  h,\n  Element,\n  State,\n  Method,\n  Host,\n  Watch,\n} from \"@stencil/core\"\nimport {\n  selectReducer,\n  getInitialState,\n  SelectState,\n  SelectActions,\n  isKeyboardBehavior,\n} from \"../select-store\"\nimport {\n  StoreConnection,\n  StateHandle,\n  computedProperty,\n  getAppearance,\n} from \"../../../core/helpers/webcomponent-helpers\"\n\n/**\n * This Web Component serves only to allow to append the list of options to the\n * body in order to overlap every thing else (overlaying).\n */\n@Component({\n  tag: \"sdx-select-list\",\n  styleUrl: \"select-list.scss\",\n  shadow: true,\n})\nexport class SelectList {\n  private store: StoreConnection<this, SelectState, SelectActions>\n  private hadPlaceholderWhenOpened?: boolean\n  private filterInputEl?: HTMLSdxInputElement\n\n  @Element() public el!: HTMLSdxSelectListElement\n\n  @State() public state!: StateHandle<SelectState>\n\n  @Watch(\"state\")\n  public stateChanged({}, prev: StateHandle<SelectState>) {\n    const state = this.state.get()\n    const prevState = prev.get()\n\n    if (state.display !== prevState.display) {\n      this.displayChanged(state)\n    }\n  }\n\n  /**\n   * @private\n   */\n  @Method()\n  public async doFocus() {\n    this.filterInputEl?.doFocus()\n  }\n\n  /**\n   * @private\n   */\n  @Method()\n  public async doBlur() {\n    this.filterInputEl!.doBlur()\n  }\n\n  constructor() {\n    this.store = new StoreConnection(this, selectReducer, getInitialState(), [\n      \"selection\",\n      \"optionEls\",\n      \"multiple\",\n      \"directionY\",\n      \"listEl\",\n      \"keyboardBehavior\",\n      \"filter\",\n      \"filterInputElValue\",\n      \"filterInputElPlaceholder\",\n      \"filterMinLength\",\n      \"noMatchesFound\",\n      \"noMatchesFoundLabel\",\n      \"placeholder\",\n      \"required\",\n      \"display\",\n      \"loading\",\n      \"isInsideDialog\",\n    ])\n  }\n\n  public connectedCallback() {\n    // Register self\n    this.store.set(\"listEl\", this.el)\n  }\n\n  public componentDidLoad() {\n    this.store.subscribe()\n  }\n\n  private displayChanged(state: SelectState) {\n    if (state.display === \"opening\") {\n      // Was the placeholder displayed when opening?\n      this.hadPlaceholderWhenOpened = this.showPlaceholder()\n    } else if (state.display === \"closed\") {\n      this.hadPlaceholderWhenOpened = undefined\n    }\n  }\n\n  /**\n   * Determines whether the placeholder option should be rendered:\n   *  - when no selection is in progress (UX: list should not grow while open),\n   *  - when something is selected,\n   *  - the placeholder prop exists\n   *  - and when single select\n   */\n  private showPlaceholder(): boolean {\n    const { selection, placeholder, multiple, required } = this.state.get()\n\n    let showPlaceholder =\n      !!selection.length && !!placeholder && !multiple && !required\n\n    if (this.hadPlaceholderWhenOpened !== undefined) {\n      showPlaceholder = this.hadPlaceholderWhenOpened\n    }\n\n    return showPlaceholder\n  }\n\n  private onFilterInput(e: Event): void {\n    const value = (e.target as HTMLSdxInputElement).value\n\n    this.store.set(\"filterInputElValue\", value)\n    this.store.dispatch({ type: \"SET_FILTER\", filter: value })\n  }\n\n  private getHostClassNames() {\n    const { display, directionY, isInsideDialog } = this.state.get()\n\n    return {\n      [getAppearance(this.el)]: true,\n      [display]: true,\n      ...computedProperty(directionY),\n      \"inside-dialog\": isInsideDialog,\n    }\n  }\n\n  public render() {\n    const state = this.state.get()\n\n    return (\n      <Host tabindex=\"-1\" class={this.getHostClassNames()}>\n        <div class=\"component\">\n          {isKeyboardBehavior(state, \"filter\") && (\n            <div class=\"filter-input-wrapper\">\n              <sdx-input\n                class=\"filter-input\"\n                value={state.filterInputElValue}\n                placeholder={state.filterInputElPlaceholder}\n                selectTextOnFocus={true}\n                clearable={true}\n                onInput={(e) => this.onFilterInput(e)}\n                ref={(el) => (this.filterInputEl = el)}\n              />\n            </div>\n          )}\n\n          {this.showPlaceholder() && (\n            <sdx-select-option placeholder={true}>\n              {state.placeholder}\n            </sdx-select-option>\n          )}\n\n          <slot />\n\n          <div\n            class=\"no-matches-found\"\n            style={{ display: state.noMatchesFound ? \"flex\" : \"none\" }}\n          >\n            <sdx-icon icon-name=\"icon-exclamation-mark\" size={2} />\n            {state.noMatchesFoundLabel}\n          </div>\n        </div>\n      </Host>\n    )\n  }\n}\n",":host(:not(.inside-dialog)) {\n  .component {\n    border-top: $border-width solid $color-gray-tint-6;\n    border-bottom: $border-width solid $color-gray-tint-6;\n\n    .name {\n      padding: 0 $select-inner-margin;\n      border-left: $border-width solid $color-gray-tint-6;\n      border-right: $border-width solid $color-gray-tint-6;\n    }\n\n    &.sdx--dark-theme {\n      border-top-color: $color-gray-tint-7-dark-theme;\n      border-bottom-color: $color-gray-tint-7-dark-theme;\n\n      .name {\n        border-left-color: $color-int-blue2-dark-theme;\n        border-right-color: $color-int-blue2-dark-theme;\n      }\n    }\n  }\n}\n\n:host {\n  display: block;\n\n  ::slotted(sdx-select-option) {\n    border-top: none;\n    border-bottom: none;\n  }\n\n  // Indent grouped options.\n  // Not needed when checkbox or radio elements are visible and provides indentation-like effect\n  ::slotted(sdx-select-option:not(.multiple):not(.inside-dialog)) {\n    padding-left: $baseline-2;\n  }\n\n  .component {\n    &.top {\n      border-top: none;\n    }\n\n    &.bottom {\n      border-bottom: none;\n    }\n\n    .name {\n      @include font-semi-bold;\n      display: flex;\n      align-items: center;\n      white-space: nowrap;\n      height: $select-height;\n    }\n  }\n}\n","import { Component, h, Prop, State, Element, Host } from \"@stencil/core\"\nimport {\n  selectReducer,\n  getInitialState,\n  SelectState,\n  SelectActions,\n} from \"../select-store\"\nimport {\n  StoreConnection,\n  StateHandle,\n  computedProperty,\n  getAppearance,\n} from \"../../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-select-optgroup\",\n  styleUrl: \"select-optgroup.scss\",\n  shadow: true,\n})\nexport class SelectOptGroup {\n  private store: StoreConnection<this, SelectState, SelectActions>\n\n  @Element() public el!: HTMLSdxSelectOptgroupElement\n\n  @State() public state!: StateHandle<SelectState>\n\n  /**\n   * Label of the group to be displayed.\n   */\n  @Prop() public name: string = \"\"\n\n  constructor() {\n    this.store = new StoreConnection(this, selectReducer, getInitialState(), [\n      \"directionX\",\n      \"directionY\",\n      \"filter\",\n    ])\n  }\n\n  public connectedCallback() {\n    // Don't do anything while the component is being reappended (maybe\n    // because it's being appended to document.body), but send a \"ping\" for\n    // each child (sdx-select-optgroup).\n    // After each child is has finished, \"reappending\" will be marked \"done\" by\n    // the store.\n    if (this.state.get().reappending) {\n      this.store?.dispatch({ type: \"UPDATE_REAPPENDING\" })\n      return\n    }\n\n    // Register self\n    this.store.dispatch({\n      type: \"ADD_OPTGROUP_EL\",\n      optgroupEl: this.el,\n    })\n  }\n\n  public disconnectedCallback() {\n    // See connectedCallback() for explanation\n    if (this.state.get().reappending) {\n      return\n    }\n\n    // Unregister self\n    this.store.dispatch({\n      type: \"REMOVE_OPTGROUP_EL\",\n      optgroupEl: this.el,\n    })\n  }\n\n  public componentDidLoad() {\n    this.store.subscribe()\n  }\n\n  private getHostClassNames() {\n    const { isInsideDialog } = this.state.get()\n\n    return {\n      \"inside-dialog\": isInsideDialog,\n    }\n  }\n\n  private getComponentClassNames() {\n    return {\n      ...computedProperty(this.state.get().directionY),\n      component: true,\n      [getAppearance(this.el)]: true,\n    }\n  }\n\n  public render() {\n    return (\n      <Host class={this.getHostClassNames()}>\n        <div class={this.getComponentClassNames()}>\n          {this.name && <div class=\"name\">{this.name}</div>}\n\n          <slot />\n        </div>\n      </Host>\n    )\n  }\n}\n","@import \"../../../globals/scss/input\";\n\n:host {\n  display: flex;\n  height: $select-height;\n  cursor: pointer;\n  color: $color-gray;\n}\n\n:host(:not(.inside-dialog)) {\n  border: $border-width solid $color-gray-tint-6;\n\n  .component {\n    .option {\n      padding: 0 $select-inner-margin;\n    }\n  }\n}\n\n:host(:hover:not(.disabled):not(.inside-dialog)),\n:host(.focus:not(.disabled):not(.inside-dialog)) {\n  background-color: $color-horizon;\n}\n\n:host(.selected:not(.multiple):not(.inside-dialog)) {\n  border-color: $color-int-blue;\n  background-color: $color-int-blue;\n  color: $color-white;\n}\n\n:host(.selected:not(.multiple):not(.inside-dialog):hover),\n:host(.selected.focus:not(.multiple):not(.inside-dialog)) {\n  border-color: $color-int-blue--active;\n  background-color: $color-int-blue--active;\n}\n\n:host(:not(.multiple):not(.inside-dialog)) {\n  label {\n    padding-left: unset;\n\n    &::before,\n    &::after {\n      display: none;\n    }\n  }\n}\n\n:host(.top) {\n  border-top: none;\n}\n\n:host(.bottom) {\n  border-bottom: none;\n}\n\n:host(.disabled) {\n  cursor: not-allowed;\n  color: $color-disabled;\n}\n\n.component {\n  display: flex;\n  flex: 1;\n  white-space: nowrap;\n\n  .option {\n    flex: 1;\n    display: flex;\n\n    .input {\n      flex: 1;\n      display: flex;\n      align-items: center;\n    }\n  }\n}\n\n:host(.sdx--dark-theme) {\n  border-right-color: $color-int-blue2-dark-theme;\n  border-left-color: $color-int-blue2-dark-theme;\n  border-top-color: $color-gray-tint-7-dark-theme;\n  border-bottom-color: $color-gray-tint-7-dark-theme;\n  color: $color-gray-dark-theme;\n}\n\n:host(:hover:not(.disabled):not(.inside-dialog).sdx--dark-theme),\n:host(.focus:not(.disabled):not(.inside-dialog).sdx--dark-theme) {\n  background-color: $color-dusk-tint-3-dark-theme;\n}\n\n:host(.selected:not(.inside-dialog).sdx--dark-theme) {\n  border-right-color: $color-int-blue2-dark-theme;\n  border-left-color: $color-int-blue2-dark-theme;\n  border-top: $color-int-blue2-dark-theme;\n  border-bottom-color: $color-int-blue2-dark-theme;\n  background-color: $color-int-blue-dark-theme;\n}\n\n:host(.selected:not(.inside-dialog).sdx--dark-theme:hover),\n:host(.selected.focus:not(.inside-dialog).sdx--dark-theme) {\n  border-right-color: $color-int-blue-dark-theme--active;\n  border-left-color: $color-int-blue2-dark-theme--active;\n  border-top-color: $color-int-blue2-dark-theme--active;\n  border-bottom-color: $color-int-blue2-dark-theme--active;\n  background-color: $color-int-blue-dark-theme--active;\n}\n\n:host(.disabled.sdx--dark-theme) {\n  color: $color-disabled-dark-theme;\n}\n","import {\n  Component,\n  h,\n  Element,\n  Listen,\n  Prop,\n  State,\n  Watch,\n  Host,\n} from \"@stencil/core\"\nimport {\n  selectReducer,\n  getInitialState,\n  SelectState,\n  SelectActions,\n  isKeyboardBehavior,\n  getDisplayText,\n} from \"../select-store\"\nimport { Strategy } from \"../types\"\nimport {\n  StoreConnection,\n  StateHandle,\n  computedProperty,\n  getAppearance,\n} from \"../../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-select-option\",\n  styleUrl: \"select-option.scss\",\n  shadow: true,\n})\nexport class SelectOption {\n  private store: StoreConnection<this, SelectState, SelectActions>\n  private selectedChangedInProgress = false\n  private selectionChangedInProgress = false\n\n  // A \"native\" hidden DOM element that is submitted when the item is used in a\n  // traditional form.\n  private lightDOMHiddenFormInputEl?: HTMLInputElement\n\n  @Element() public el!: HTMLSdxSelectOptionElement\n\n  @State() public state!: StateHandle<SelectState>\n\n  /**\n   * Value of the option that will be added to the sdx-select's value when\n   * selected.\n   */\n  @Prop() public value: any\n\n  /**\n   * Text to show within the sdx-select when selected. If not provided, the\n   * option's `.textContent` is displayed. This property should only be used in\n   * rare cases, e.g. when HTML is used to decorate the option with additinal\n   * HTML.\n   * When used in combination with `keyboard-behavior=\"autocomplete\"`, the\n   * sdx-select's `filterFunction` might be needed, which by default also\n   * filters the option's `.textContent`.\n   */\n  @Prop() public displayText?: string\n\n  /**\n   * Whether this option is initially selected.\n   */\n  @Prop({ mutable: true }) public selected: boolean = false\n\n  /**\n   * Not selectable (event propagation will be stopped).\n   */\n  @Prop() public disabled: boolean = false\n\n  /**\n   * Whether this option is the placeholder element.\n   * @private\n   */\n  @Prop() public placeholder: boolean = false\n\n  @Watch(\"state\")\n  public stateChanged({}, prev: StateHandle<SelectState>) {\n    const state = this.state.get()\n    const prevState = prev.get()\n\n    if (state.selection !== prevState.selection) {\n      this.selectionChanged()\n    }\n\n    if (state.name !== prevState.name) {\n      this.nameChanged()\n    }\n  }\n\n  @Watch(\"selected\")\n  public selectedChanged() {\n    this.selectedChangedInProgress = true\n\n    if (!this.selectionChangedInProgress) {\n      this.select(this.selected ? \"add\" : \"remove\")\n      this.updateHiddenFormInputEl()\n    }\n\n    this.selectedChangedInProgress = false\n  }\n\n  @Listen(\"click\")\n  public onClick() {\n    const state = this.state.get()\n    const closeAutomatically = this.shouldCloseAutomatically()\n\n    if (this.disabled) {\n      if (closeAutomatically) {\n        state.close()\n      }\n    } else {\n      // Don't select anything if \"autocomplete\", only set the filter keyword\n      if (isKeyboardBehavior(state, \"autocomplete\")) {\n        const value = getDisplayText(this.el)\n\n        this.store.set(\"userInteractionInProgress\", true)\n        this.store.set(\"filterInputElValue\", value)\n        this.store.set(\"userInteractionInProgress\", false)\n\n        // Close with a little delay for the user to see what was selected\n        setTimeout(() => {\n          // Apply filter *after* the autocomplete has closed in order to\n          // prevent glitches. Otherwise, for a brief moment, all results are\n          // being displayed again.\n          state\n            .close()\n            .then(() =>\n              this.store.dispatch({ type: \"SET_FILTER\", filter: value })\n            )\n        }, state.animationDuration)\n\n        return\n      }\n\n      const alreadySelected = this.isSelected()\n\n      this.store.set(\"userInteractionInProgress\", true)\n\n      this.select(\"add\")\n\n      if (closeAutomatically) {\n        // Close with a little delay for the user to see what was selected\n        setTimeout(() => {\n          state.close().then(() => {\n            // Clear the filter after an option was selected (that wasn't\n            // selected before)\n            if (alreadySelected) {\n              return\n            }\n\n            this.store.set(\"filterInputElValue\", \"\")\n            this.store.dispatch({ type: \"SET_FILTER\", filter: \"\" })\n          })\n        }, state.animationDuration)\n      }\n    }\n  }\n\n  constructor() {\n    this.store = new StoreConnection(this, selectReducer, getInitialState(), [\n      \"selection\",\n      \"multiple\",\n      \"directionX\",\n      \"directionY\",\n      \"name\",\n      \"filter\",\n      \"animationDuration\",\n      \"close\",\n      \"keyboardBehavior\",\n      \"isInsideDialog\",\n    ])\n  }\n\n  public connectedCallback() {\n    // Don't do anything while the component is being reappended (maybe\n    // because it's being appended to document.body), but send a \"ping\" for\n    // each child (sdx-select-option).\n    // After each child is has finished, \"reappending\" will be marked \"done\" by\n    // the store.\n    if (this.state.get().reappending) {\n      this.store?.dispatch({ type: \"UPDATE_REAPPENDING\" })\n      return\n    }\n\n    // Register self (except placeholder)\n    this.store.dispatch({ type: \"ADD_OPTION_EL\", optionEl: this.el })\n\n    if (this.selected) {\n      this.select(\"add\")\n    }\n  }\n\n  public disconnectedCallback() {\n    // Performance: stop if the parent isn't even connected (e.g. *ngIf)\n    if (!this.state.get().connected) {\n      return\n    }\n\n    // See connectedCallback() for explanation\n    if (this.state.get().reappending) {\n      return\n    }\n\n    // Unregister self\n    this.store.dispatch({ type: \"REMOVE_OPTION_EL\", optionEl: this.el })\n\n    if (!this.el.isConnected && this.selected) {\n      this.select(\"remove\")\n    }\n  }\n\n  public componentDidLoad() {\n    this.store.subscribe()\n  }\n\n  private selectionChanged() {\n    this.selectionChangedInProgress = true\n\n    if (!this.selectedChangedInProgress) {\n      this.selected = this.isSelected()\n      this.updateHiddenFormInputEl()\n    }\n\n    this.selectionChangedInProgress = false\n  }\n\n  private nameChanged() {\n    this.updateHiddenFormInputEl()\n  }\n\n  private updateHiddenFormInputEl(): void {\n    const state = this.state.get()\n\n    // See sdx-select for more information.\n    if (isKeyboardBehavior(state, \"autocomplete\")) {\n      return\n    }\n\n    if (!this.lightDOMHiddenFormInputEl) {\n      this.lightDOMHiddenFormInputEl = document.createElement(\"input\")\n      this.lightDOMHiddenFormInputEl.type = \"hidden\"\n      this.el.append(this.lightDOMHiddenFormInputEl)\n    }\n\n    // Clean up properties added previously in case they've changed\n    this.lightDOMHiddenFormInputEl.removeAttribute(\"name\")\n    this.lightDOMHiddenFormInputEl.removeAttribute(\"value\")\n\n    if (state.name && this.selected) {\n      this.lightDOMHiddenFormInputEl.name = state.name\n      this.lightDOMHiddenFormInputEl.value = this.value || this.el.textContent\n    }\n  }\n\n  private select(strategy: Strategy): void {\n    this.store.dispatch({\n      type: \"SELECT\",\n      optionEl: this.placeholder ? null : this.el,\n      strategy,\n    })\n  }\n\n  public isSelected(): boolean {\n    return !!this.state.get().selection.includes(this.el)\n  }\n\n  private shouldCloseAutomatically() {\n    const { multiple, isInsideDialog } = this.state.get()\n    return !(multiple || isInsideDialog)\n  }\n\n  private getHostClassNames() {\n    const { multiple, directionY, isInsideDialog } = this.state.get()\n\n    return {\n      multiple,\n      [getAppearance(this.el)]: true,\n      selected: this.isSelected(),\n      disabled: this.disabled,\n      ...computedProperty(directionY),\n      \"inside-dialog\": isInsideDialog,\n    }\n  }\n\n  private getInputClassNames() {\n    const { multiple } = this.state.get()\n\n    return {\n      input: true,\n      checkbox: multiple,\n      radio: !multiple,\n      [getAppearance(this.el)]: true,\n    }\n  }\n\n  public render() {\n    const inputClassNames = this.getInputClassNames()\n    const { checkbox } = inputClassNames\n\n    return (\n      <Host class={this.getHostClassNames()}>\n        <div class=\"component\">\n          <div class=\"option\">\n            <div class={inputClassNames}>\n              {/* <sdx-input-item> is too slow with 1000+ items (even\n                  <sdx-dummy is too slow - it's Stencil, see\n                  https://github.com/ionic-team/stencil/issues/3569) */}\n              <input\n                id=\"input\"\n                type={checkbox ? \"checkbox\" : \"radio\"}\n                checked={this.isSelected()}\n                disabled={this.disabled}\n                onClick={\n                  (e) =>\n                    e.stopPropagation() /* already handled in components click listener */\n                }\n                onInput={(e) => e.stopPropagation()}\n              />\n\n              <label htmlFor=\"input\" class=\"has-text\">\n                <slot />\n              </label>\n            </div>\n          </div>\n        </div>\n      </Host>\n    )\n  }\n}\n","export default function _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}"],"names":["breakpoints","xs","sm","md","lg","xl","ul","bp","breakpoint","window","innerWidth","add","list","item","includes","remove","filter","currentItem","toggle","objectMap","obj","cb","newObj","key","getFormattedSelection","selection","length","map","getDisplayText","join","isKeyboardBehavior","store","keyboardBehavior","isMatch","filterable","isFilterLongEnough","filterMinLength","isValidFilter","optionEl","displayText","textContent","_a","trim","selectReducer","state","action","type","multiple","alreadySelected","strategy","sort","sortByAppearanceInDomTree","optionEls","optgroupEls","optgroupEl","filterInputElValue","reappendedItems","reappending","getInitialState","directionX","directionY","listEl","undefined","name","filterInputElPlaceholder","noMatchesFound","noMatchesFoundLabel","animationDuration","connected","userInteractionInProgress","placeholder","required","display","loading","close","Promise","resolve","isInsideDialog","Select","invokeSelectCallback","invokeChangeCallback","invokeFilterCallback","invokeFocusCallback","invokeBlurCallback","isTabDown","componentDidLoadComplete","hadFilterInputElFocus","isReappending","hasConsumerProvidedListEl","parsedFilterFunction","visualViewportResizeHandler","get","isClosedOrClosing","visualViewport","virtualKeyboardVisible","innerHeight","height","listElRectTop","getBoundingClientRect","top","style","maxHeight","valueChangedInProgress","filterInputElValueChangedInProgress","selectionChangedInProgress","optionElsDidUpdate","lastScreenOrientationAngle","translate","this","el","lang","StoreConnection","setInvokeSelectCallback","setInvokeChangeCallback","setInvokeFilterCallback","setInvokeFocusCallback","setInvokeBlurCallback","setFilterFunction","set","animated","bind","filterInputPlaceholder","setIsInsideDialog","flush","maxAutocompleteOptions","maxAutocompleteOptionsDesktop","maxAutocompleteOptionsMobile","updateHiddenFormInputEl","addEventListener","prev","prevState","selectionChanged","optionElsChanged","filterChanged","filterInputElValueChanged","value","dispatch","getByValues","allValuesValid","validatedValues","resetFilter","showNoMatchesFoundIfNecessary","e","focussed","composedPath","dialogEl","getDisplay","dialogDisplay","currentAngle","getScreenOrientationAngle","positionListEl","hasFilterInputElFocus","preventDefault","isOpenOrOpening","focussedEl","click","setFocussedEl","hasVisibleOptionEls","open","isFilterable","setFocussedElByFirstLetter","then","overlayOutletEl","getOverlayOutletEl","scrollContainerEl","getScrollContainerEl","document","documentElement","appendTo","anime","targets","scaleY","opacity","scrollTop","duration","getAnimationDuration","easing","complete","transform","nonEditableInputEl","doFocus","filterInputEl","KeyboardEvent","didClickOnEl","didClickOnListEl","isChildOfSdxFilter","closest","removeEventListener","selectFirstOptionElIfNecessary","autofocus","subscribe","dispatchEvent","eventInput","sdxfilter","emit","keyword","target","appendToOverlayOutlet","append","getDirectSlotEls","dialogContentEl","wrapperEl","lightDOMHiddenFormInputEl","createElement","removeAttribute","resetFilterInputEl","optionElMatchesFilter","componentEl","minWidth","inset","transformOrigin","wrapperElRect","spaceTowards","bottom","clientHeight","left","right","clientWidth","maxHeightFromProp","getMaxHeight","scrollContainerElRect","listElWidth","listElHeight","selectHeight","minSpaceToWindow","heightOfTwoOptions","width","getScrollTopLeft","scrollLeft","toLowerCase","indexOf","filterFunction","defaultFilterFunction","parseFunction","match","which","i","classList","lastSelectedEl","prevEl","getPreviousFromList","count","disabled","nextEl","getNextFromList","scrollToOption","option","parent","optionRect","parentRect","letter","results","charAt","push","optionsByFirstLetter","getOptionElsByFirstLetter","startIndex","focussedElIndex","selectCallback","changeCallback","filterCallback","focusCallback","blurCallback","values","Array","isArray","definedValues","foundOptionEls","isValid","foundOptionEl","find","optionsNotDisabled","matches","forEach","querySelectorAll","targetEl","didClickOnSdxInputEl","resizeTimer","clearTimeout","setTimeout","some","optioneEl","Number","String","isTouchscreen","shadowRoot","activeElement","valid","srHint","label","validationMessage","role","ariaExpanded","component","focus","invalid","autocomplete","isListOverlapping","backgroundTheme","getAppearance","notClosed","openTowardsTop","openTowardsBottom","notClosedTowardsTop","notClosedTowardsBottom","paddingRight","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","appearance","h","Host","toString","class","getComponentClassNames","ref","getLabelClassNames","onClick","onHeaderClick","getDefaultInputFieldProps","maxlength","editable","inputStyle","getDefaultInputFieldStyle","onInput","onAutocompleteInput","onFocus","onAutocompleteFocus","onBlur","onAutocompleteBlur","badge","borderColor","color","strokeInherit","onSdxdisplaychange","detail","_b","fixedHeight","SelectList","displayChanged","doBlur","hadPlaceholderWhenOpened","showPlaceholder","computedProperty","tabindex","getHostClassNames","selectTextOnFocus","clearable","onFilterInput","size","SelectOptGroup","SelectOption","selectedChangedInProgress","nameChanged","select","selected","closeAutomatically","shouldCloseAutomatically","isSelected","isConnected","input","checkbox","radio","inputClassNames","getInputClassNames","id","checked","stopPropagation","htmlFor","_objectDestructuringEmpty","TypeError"],"sourceRoot":""}