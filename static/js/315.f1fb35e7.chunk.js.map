{"version":3,"file":"static/js/315.f1fb35e7.chunk.js","mappings":"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","sources":["../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/pie-chart/pie-chart.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/pie-chart/pie-chart.scss?tag=sdx-pie-chart&encapsulation=shadow","../node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js"],"sourcesContent":["import { Component, h, Element, Prop, Watch } from \"@stencil/core\"\nimport anime from \"animejs\"\nimport { PieChartDataPoint } from \"./types\"\nimport { BackgroundTheme } from \"../../core/types/types\"\nimport {\n  parseJson,\n  getAppearance,\n} from \"../../core/helpers/webcomponent-helpers\"\n\ntype Segment = {\n  d: PieChartDataPoint\n  width: number\n  rotation: number\n  circle?: SVGElement\n}\n\n@Component({\n  tag: \"sdx-pie-chart\",\n  styleUrl: \"pie-chart.scss\",\n  shadow: true,\n})\nexport class PieChart {\n  private dataParsed: PieChartDataPoint[]\n\n  @Element() public el!: HTMLSdxPieChartElement\n\n  private readonly viewBox = 34\n  private readonly radius = 16\n  private readonly segmentPaddingForSizeSmall = 0\n  private readonly segmentPaddingForSizeMedium = 3\n  private readonly hundredPercent = this.radius * 2 * Math.PI\n  private readonly animationDuration = 300\n\n  /**\n   * The values to display (using accent colors in the following order):\n   * \"azure\",\n   * \"turquoise\",\n   * \"iris\",\n   * \"orchid\",\n   * \"pink\".\n   * For empty values, like \"Available\", the \"color\" property can be omitted.\n   */\n  @Prop() public data: PieChartDataPoint[] | string = []\n\n  /**\n   * Text that contains the relevant information (e.g. \"100 %\").\n   * It will be displayed in the center of the chart.\n   */\n  @Prop() public value: string = \"\"\n\n  /**\n   * Description text of what is displayed (e.g. \"Storage\" or \"Available\").\n   * This does not appear in the \"small\" version.\n   */\n  @Prop() public description?: string\n\n  /**\n   * Where to render the labels.\n   */\n  @Prop() public legendPosition: \"bottom\" | \"right\" = \"bottom\"\n\n  /**\n   * Dimension of the chart.\n   */\n  @Prop() public size: \"small\" | \"medium\" = \"medium\"\n\n  /**\n   * Background color scheme.\n   */\n  @Prop() public backgroundTheme: BackgroundTheme = \"light\"\n\n  @Watch(\"data\")\n  public dataChanged() {\n    this.dataParsed = parseJson(this.data) || []\n  }\n\n  constructor() {\n    this.dataParsed = parseJson(this.data) || []\n  }\n\n  private animateSegment(\n    segment: Segment,\n    timeline: anime.AnimeTimelineInstance\n  ) {\n    if (!segment.circle) {\n      return\n    }\n\n    // Initial stroke-dasharray\n    segment.circle.style.strokeDasharray = `0 ${this.hundredPercent}`\n\n    timeline.add({\n      targets: segment.circle,\n      begin: () => (segment.circle!.style.display = \"\"),\n      strokeDasharray: `${segment.width} ${this.hundredPercent}`,\n      duration: this.animationDuration,\n      easing: \"easeInQuint\",\n    })\n  }\n\n  private animateLegendItem(\n    legendItem: HTMLLIElement,\n    timeline: anime.AnimeTimelineInstance\n  ) {\n    if (!legendItem) {\n      return\n    }\n\n    timeline.add({\n      targets: legendItem,\n      opacity: 1,\n      duration: this.animationDuration,\n      easing: \"easeInQuint\",\n    })\n  }\n\n  /**\n   * Read the data and create a pie part (segment) for every data point.\n   * The SDX pie chart is special in two ways:\n   * 1. it has a spacing between the segments (called segmentPadding)\n   * 2. small values (values smaller than the segmentPadding) are represented by only a dot.\n   *    This makes the math behind *special*, for example:\n   *    If a chart has the values [1, 1, 1, 1000], the three \"1\" use up much more space than\n   *    they would in an ordinary pie chart (where they would be hardly recognizable).\n   *    This limits the amount of data segments (e.g. [1 * 50, 1000] ends up glitchy).\n   */\n  private dataToSegments(): Segment[] {\n    const segmentPadding =\n      this.size === \"medium\"\n        ? this.segmentPaddingForSizeMedium\n        : this.segmentPaddingForSizeSmall\n\n    // Calculate the \"max\"\n    const totalValue = this.dataParsed.reduce((total, d) => total + d.value, 0)\n\n    const segmentsSmallerThanPadding = this.dataParsed.filter((d) => {\n      let width = (d.value / totalValue) * this.hundredPercent\n      return width < segmentPadding\n    })\n\n    const totalValueOfSegmentsSmallerThanPadding =\n      segmentsSmallerThanPadding.reduce((total, d) => {\n        return total + d.value\n      }, 0)\n\n    const segmentPaddingRotationDeg =\n      (360 / this.hundredPercent) * segmentPadding\n    let rotation = segmentPaddingRotationDeg // initial\n\n    return this.dataParsed\n      .filter(({}, i) => (this.size === \"small\" ? i === 0 : true)) // \"small\" only has one segment\n      .map((d) => {\n        // Calculate how much space is left without all the small segments\n        // (a.k.a. calculate the \"real\" 100%)\n        const availableWidth =\n          this.hundredPercent -\n          segmentPadding * segmentsSmallerThanPadding.length\n\n        let width =\n          (d.value / (totalValue - totalValueOfSegmentsSmallerThanPadding)) *\n          availableWidth\n\n        if (width < segmentPadding) {\n          // Small values are represented by only a dot (using CSS \"stroke-linecap: round;\")\n          width = 0\n        } else {\n          // Create padding\n          width = width - segmentPadding\n        }\n\n        const segment: Segment = { d, width, rotation }\n\n        rotation += this.widthToDeg(segment.width) + segmentPaddingRotationDeg\n\n        return segment\n      })\n  }\n\n  private widthToDeg(width: number): number {\n    return (360 / this.hundredPercent) * width\n  }\n\n  private getComponentClassNames() {\n    return {\n      component: true,\n      [getAppearance(this.el)]: true,\n      [this.legendPosition]: true,\n      [this.size]: true,\n      [this.backgroundTheme]: true,\n    }\n  }\n\n  private hasLabelsOrSrHints(): boolean {\n    return this.dataParsed.some(this.hasLabelOrSrHint)\n  }\n\n  private hasLabelOrSrHint(d: PieChartDataPoint): boolean {\n    return !!d.label || !!d.srHint\n  }\n\n  public render() {\n    const center = this.viewBox / 2\n    const segmentsTimeline = anime.timeline()\n    const legendItemsTimeline = anime.timeline()\n\n    return (\n      <div class={this.getComponentClassNames()}>\n        <div class=\"wrapper\">\n          <div class=\"chart-container\">\n            <div class=\"chart\">\n              {/* \"small\" charts always have a background (because of the animation) */}\n              {this.size === \"small\" && (\n                <svg\n                  viewBox={`0 0 ${this.viewBox} ${this.viewBox}`}\n                  style={{\n                    transform: `rotate(${this.widthToDeg(\n                      this.hundredPercent\n                    )}deg)`,\n                  }}\n                >\n                  <circle cx={center} cy={center} r={this.radius} />\n                </svg>\n              )}\n\n              {this.dataToSegments().map((segment) => {\n                return (\n                  <svg\n                    key={\n                      Math.random() /* make sure elements are not reused (causing glitchy animations) */\n                    }\n                    viewBox={`0 0 ${this.viewBox} ${this.viewBox}`}\n                    style={{ transform: `rotate(${segment.rotation}deg)` }}\n                  >\n                    <circle\n                      class={segment.d.color}\n                      ref={(el) =>\n                        this.animateSegment(\n                          { ...segment, circle: el },\n                          segmentsTimeline\n                        )\n                      }\n                      style={{\n                        display:\n                          \"none\" /* will be displayed during animation */,\n                      }}\n                      cx={center}\n                      cy={center}\n                      r={this.radius}\n                    />\n                  </svg>\n                )\n              })}\n            </div>\n\n            <div class=\"metadata\" aria-hidden=\"true\">\n              <div class=\"value\">{this.value}</div>\n\n              {this.size !== \"small\" && (\n                <div class=\"description\">{this.description}</div>\n              )}\n            </div>\n          </div>\n\n          {/* Render labels (if there is at least one - or omit them in case of \"Empty state\" charts) */}\n          {this.hasLabelsOrSrHints() && (\n            <ul class={{ legend: true, \"sr-only\": this.size === \"small\" }}>\n              {this.dataParsed.filter(this.hasLabelOrSrHint).map((d) => {\n                return (\n                  <li\n                    key={\n                      Math.random() /* make sure elements are not reused (causing glitchy animations) */\n                    }\n                    ref={(el) =>\n                      this.animateLegendItem(el!, legendItemsTimeline)\n                    }\n                    style={{ opacity: \"0\" }}\n                  >\n                    <span aria-hidden=\"true\">\n                      <sdx-icon\n                        iconName=\"icon-record-filled\"\n                        colorClass={d.color || \"gray-tint-8\"}\n                      />{\" \"}\n                      {d.label}\n                    </span>\n\n                    {/* Screenreaders */}\n                    {d.srHint && <span class=\"sr-only\">{d.srHint}</span>}\n                  </li>\n                )\n              })}\n            </ul>\n          )}\n        </div>\n      </div>\n    )\n  }\n}\n","@import \"stylesheets/sdx/utilities/screenreaders\";\n\n$dimension-small: 64px;\n$dimension-medium: 182px;\n$metadata-padding-small: $baseline; // padding towards inside text\n$metadata-padding-medium: $baseline * 3; // padding towards inside text\n\n.component {\n  display: flex;\n  justify-content: center;\n\n  &.small {\n    .wrapper {\n      .chart-container {\n        .chart {\n          height: $dimension-small;\n          width: $dimension-small;\n\n          svg {\n            height: $dimension-small;\n            width: $dimension-small;\n            stroke-linecap: butt;\n\n            circle {\n              stroke: $color-gray-tint-8;\n\n              &.azure {\n                stroke: $color-azure;\n              }\n\n              &.turquoise {\n                stroke: $color-turquoise;\n              }\n\n              &.iris {\n                stroke: $color-iris;\n              }\n\n              &.orchid {\n                stroke: $color-orchid;\n              }\n\n              &.pink {\n                stroke: $color-pink;\n              }\n            }\n          }\n        }\n\n        .metadata {\n          font-size: 16px;\n          top: $metadata-padding-small;\n          right: $metadata-padding-small;\n          bottom: $metadata-padding-small;\n          left: $metadata-padding-small;\n        }\n      }\n    }\n  }\n\n  &.bottom {\n    .wrapper {\n      flex-direction: column;\n      flex-basis: 100%; // IE11 (for .legend \"flex-wrap\")\n\n      .legend {\n        margin-top: $baseline * 3;\n        flex-wrap: wrap;\n        width: 100%; // IE11 (for .legend \"flex-wrap\")\n\n        li {\n          &:not(:last-of-type) {\n            margin-right: $baseline * 3;\n          }\n        }\n      }\n    }\n  }\n\n  &.right {\n    .wrapper {\n      .legend {\n        margin-left: $baseline * 4;\n        flex-direction: column;\n\n        li {\n          &:not(:last-of-type) {\n            margin-bottom: $baseline;\n          }\n        }\n      }\n    }\n  }\n\n  &.dark {\n    .wrapper {\n      .chart-container {\n        .metadata {\n          &,\n          .description {\n            color: $color-sc-white;\n          }\n        }\n      }\n    }\n  }\n\n  .wrapper {\n    display: flex;\n    align-items: center;\n\n    .chart-container {\n      position: relative; // for .metadata\n\n      .chart {\n        transform: rotate(-90deg);\n        height: $dimension-medium;\n        width: $dimension-medium;\n\n        svg {\n          position: absolute;\n          top: 0;\n          left: 0;\n          fill: transparent;\n          stroke-width: 2;\n          stroke-linecap: round;\n\n          // IE11: set dimension again (even though they're\n          // already set on .chart), otherwise it resizes:\n          height: $dimension-medium;\n          width: $dimension-medium;\n\n          circle {\n            stroke: $color-gray-tint-8;\n\n            &.azure {\n              stroke: $color-azure;\n            }\n\n            &.turquoise {\n              stroke: $color-turquoise;\n            }\n\n            &.iris {\n              stroke: $color-iris;\n            }\n\n            &.orchid {\n              stroke: $color-orchid;\n            }\n\n            &.pink {\n              stroke: $color-pink;\n            }\n          }\n        }\n      }\n\n      .metadata {\n        @include typo-pie-chart-title;\n        position: absolute;\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n        top: $metadata-padding-medium + $baseline;\n        right: $metadata-padding-medium;\n        bottom: $metadata-padding-medium;\n        left: $metadata-padding-medium;\n\n        .description {\n          font-size: 16px;\n          color: $color-gray-tint-4;\n          white-space: nowrap;\n          width: 100%;\n          overflow: hidden;\n          text-overflow: ellipsis;\n          text-align: center;\n        }\n      }\n    }\n\n    .legend {\n      display: flex;\n      list-style: none;\n      padding: 0;\n      font-weight: 300;\n      justify-content: center;\n      margin: 0;\n\n      li {\n        white-space: nowrap;\n      }\n    }\n  }\n}\n\n.component.sdx--dark-theme {\n  &.small {\n    .wrapper {\n      .chart-container {\n        .chart {\n          svg {\n            circle {\n              stroke: $color-gray-tint-8-dark-theme;\n\n              &.azure {\n                stroke: $color-azure-dark-theme;\n              }\n\n              &.turquoise {\n                stroke: $color-turquoise-dark-theme;\n              }\n\n              &.iris {\n                stroke: $color-iris-dark-theme;\n              }\n\n              &.orchid {\n                stroke: $color-orchid-dark-theme;\n              }\n\n              &.pink {\n                stroke: $color-pink-dark-theme;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  .wrapper {\n    .chart-container {\n      .metadata {\n        .description {\n          color: $color-gray-dark-theme;\n        }\n      }\n\n      svg {\n        circle {\n          stroke: $color-gray-tint-8-dark-theme;\n\n          &.azure {\n            stroke: $color-azure-dark-theme;\n          }\n\n          &.turquoise {\n            stroke: $color-turquoise-dark-theme;\n          }\n\n          &.iris {\n            stroke: $color-iris-dark-theme;\n          }\n\n          &.orchid {\n            stroke: $color-orchid-dark-theme;\n          }\n\n          &.pink {\n            stroke: $color-pink-dark-theme;\n          }\n        }\n      }\n    }\n  }\n}\n","export default function _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}"],"names":["PieChart","viewBox","radius","segmentPaddingForSizeSmall","segmentPaddingForSizeMedium","hundredPercent","this","Math","PI","animationDuration","dataParsed","parseJson","data","segment","timeline","circle","style","strokeDasharray","add","targets","begin","display","width","duration","easing","legendItem","opacity","segmentPadding","size","totalValue","reduce","total","d","value","segmentsSmallerThanPadding","filter","totalValueOfSegmentsSmallerThanPadding","segmentPaddingRotationDeg","rotation","i","map","availableWidth","length","widthToDeg","component","getAppearance","el","legendPosition","backgroundTheme","some","hasLabelOrSrHint","label","srHint","center","segmentsTimeline","anime","legendItemsTimeline","h","class","getComponentClassNames","transform","cx","cy","r","dataToSegments","key","random","color","ref","animateSegment","description","hasLabelsOrSrHints","legend","animateLegendItem","iconName","colorClass","_objectDestructuringEmpty","obj","TypeError"],"sourceRoot":""}