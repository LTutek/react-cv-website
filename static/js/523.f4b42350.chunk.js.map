{"version":3,"file":"static/js/523.f4b42350.chunk.js","mappings":"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","sources":["../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/backdrop/backdrop.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/backdrop/backdrop.scss?tag=sdx-backdrop&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/expand-and-collapse/expand-and-collapse.scss?tag=sdx-expand-and-collapse&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/expand-and-collapse/expand-and-collapse.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/filter/filter.scss?tag=sdx-filter&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/filter/filter.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/scroll-view/scroll-view.scss?tag=sdx-scroll-view&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/scroll-view/scroll-view.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/trap-focus/trap-focus.scss?tag=sdx-trap-focus&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/trap-focus/trap-focus.tsx"],"sourcesContent":["import { Component, h, Element } from \"@stencil/core\"\nimport { getAppearance } from \"../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-backdrop\",\n  styleUrl: \"backdrop.scss\",\n  shadow: true,\n})\nexport class Backdrop {\n  @Element() public el!: HTMLSdxBackdropElement\n\n  private getComponentClassNames() {\n    return {\n      component: true,\n      [getAppearance(this.el)]: true,\n    }\n  }\n\n  public render() {\n    return (\n      <div class={this.getComponentClassNames()}>\n        <div class=\"background\"></div>\n\n        <div class=\"slot row row--no-gutters flex-items-xs-center flex-items-xs-bottom flex-items-sm-middle\">\n          <slot />\n        </div>\n      </div>\n    )\n  }\n}\n","// Allows to contain items with col-* classes (like sdx-dialog-content)\n@import \"stylesheets/sdx/grid/grid\";\n\n:host {\n  display: none;\n  position: fixed;\n  top: 0;\n  left: 0;\n  height: 100vh;\n  width: 100vw;\n  z-index: $zindex-topmost - 1;\n\n  // Needed for macOS Safari 16.3 (and also iOS 16)\n  -webkit-backdrop-filter: blur(4px) brightness(50%);\n}\n\n.component {\n  height: var(--sdx-dialog-window-inner-height, 100%);\n\n  .background {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n  }\n\n  // because sdx-backdrop is the parent of sdx-dialog-content and it creates the possibility for col-* classes\n  .slot {\n    position: relative; // overlap absolute\n    height: 100%;\n  }\n}\n","@import \"stylesheets/sdx/utilities/screenreaders\";\n\n.component {\n  sdx-accordion-item-header {\n    &:hover {\n      span {\n        color: $color-link--active;\n      }\n    }\n\n    span {\n      color: $color-link;\n      transition: color 200ms $button-easing;\n    }\n  }\n}\n\n.component.sdx--dark-theme {\n  sdx-accordion-item-header {\n    &:hover {\n      span {\n        color: $color-int-blue2-dark-theme--active;\n      }\n    }\n\n    span {\n      color: $color-int-blue2-dark-theme;\n    }\n  }\n}\n","import { Component, h, Element, Prop } from \"@stencil/core\"\nimport { ExpandAndCollapseArrowPosition } from \"./types\"\nimport { getAppearance } from \"../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-expand-and-collapse\",\n  styleUrl: \"expand-and-collapse.scss\",\n  shadow: true,\n})\nexport class ExpandAndCollapse {\n  @Element() public el!: HTMLSdxButtonElement\n  /**\n   * Emitted when the component's visibility updates.\n   * @event\n   * @param display \"open\" | \"opening\" | \"closed\" | \"closing\"\n   */\n  // @ts-ignore just for documentation purposes\n  private static eventSdxDisplayChange = \"sdxdisplaychange\"\n\n  /**\n   * If the component is open or closed.\n   */\n  @Prop({ mutable: true }) public open: boolean = false\n\n  /**\n   * Label that shows when the component is collapsed and ready to be expanded.\n   */\n  @Prop() public expandLabel: string = \"\"\n\n  /**\n   * Label that shows when the component is expanded and ready to be collapsed.\n   */\n  @Prop() public collapseLabel: string = \"\"\n\n  /**\n   * Position of the collapse label (above or below the expanded content)\n   */\n  @Prop() public arrowPosition: ExpandAndCollapseArrowPosition = \"fixed\"\n\n  /**\n   * Description text read by the screen reader. Will be appended to the button content.\n   */\n  @Prop() public srHint: string = \"\"\n\n  private toggle() {\n    this.open = !this.open\n  }\n\n  private getAccordionStyles(): Record<\n    string,\n    Record<string, string | undefined>\n  > {\n    return {\n      accordion: {\n        border: \"none\",\n        borderRadius: \"0\",\n      },\n      header: {\n        fontSize: \"inherit\",\n        padding: \"0\",\n        justifyContent: \"flex-end\",\n        alignItems: \"flex-start\",\n      },\n      body: {\n        margin: this.arrowPosition === \"dynamic\" ? \"0 0 8px 0\" : \"8px 0 0 0\", // $baseline\n      },\n      arrow: {\n        top: \"12px\", // align arrow with first line of label's text\n      },\n    }\n  }\n\n  private getComponentClassNames() {\n    return {\n      component: true,\n      [getAppearance(this.el)]: true,\n    }\n  }\n\n  private createHeader() {\n    const { arrow, header } = this.getAccordionStyles()\n\n    return (\n      <sdx-accordion-item-header\n        id=\"header\"\n        onClick={() => this.toggle()}\n        arrowStyle={arrow}\n        buttonStyle={header}\n      >\n        <span>{this.open ? this.collapseLabel : this.expandLabel}</span>\n        {this.srHint && <span class=\"sr-only\">&nbsp;{this.srHint}</span>}\n      </sdx-accordion-item-header>\n    )\n  }\n\n  public render() {\n    return (\n      <sdx-accordion\n        arrowPosition=\"left\"\n        componentStyle={this.getAccordionStyles().accordion}\n        class={this.getComponentClassNames()}\n      >\n        <sdx-accordion-item open={this.open}>\n          {this.arrowPosition === \"fixed\" && this.createHeader()}\n\n          <sdx-accordion-item-body\n            role=\"region\"\n            aria-labelledby=\"header\"\n            componentStyle={this.getAccordionStyles().body}\n          >\n            <slot />\n          </sdx-accordion-item-body>\n\n          {this.arrowPosition === \"dynamic\" && this.createHeader()}\n        </sdx-accordion-item>\n      </sdx-accordion>\n    )\n  }\n}\n","@import \"stylesheets/sdx/grid/grid\";\n\n:host {\n  display: block;\n}\n\n.component {\n  .chips-wrapper {\n    display: flex;\n    gap: $baseline-2;\n\n    .chip {\n      flex: 0 0 auto;\n    }\n  }\n}\n","import {\n  Component,\n  h,\n  Element,\n  Prop,\n  Event,\n  EventEmitter,\n  Watch,\n} from \"@stencil/core\"\nimport { animation, translate } from \"../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-filter\",\n  styleUrl: \"filter.scss\",\n  shadow: true,\n})\nexport class Filter {\n  private chips: Map<string, HTMLSdxButtonElement> = new Map()\n  private selectedOptionsRemoved: string[] = []\n  private selectedOptionsAdded: string[] = []\n  private scrollViewEl?: HTMLSdxScrollViewElement\n\n  @Element() public el!: HTMLSdxFilterElement\n\n  /**\n   * All the selected filter options\n   */\n  @Prop() public selection: string[] = []\n\n  /**\n   * The text of the \"show more...\" element\n   */\n  @Prop() public showMoreLabel: string = translate(\n    \"Show more filters\",\n    this.el.lang\n  )\n\n  /**\n   * The text of the \"show less...\" element\n   */\n  @Prop() public showLessLabel: string = translate(\n    \"Show less filters\",\n    this.el.lang\n  )\n\n  /**\n   * The text of the \"Reset all filters\" chip\n   */\n  @Prop() public resetAllFiltersLabel: string = translate(\n    \"Reset all filters\",\n    this.el.lang\n  )\n\n  /**\n   * The text of the result label\n   */\n  @Prop() public resultLabel: string = \"\"\n\n  /**\n   * Disable animations for testing.\n   * @private\n   */\n  @Prop() public animated: boolean = true\n\n  /**\n   * Emitted when user clicks on a chip\n   */\n  @Event() public sdxdeselectrequest!: EventEmitter<{ label: string }>\n\n  @Watch(\"selection\") public onSelectedOptionsChanged(\n    newSelection: string[],\n    oldSelection: string[]\n  ) {\n    // mark options to show remove animation in componentWillUpdate\n    oldSelection.forEach((oldOption) => {\n      if (!newSelection.includes(oldOption)) {\n        this.selectedOptionsRemoved.push(oldOption)\n      }\n    })\n\n    if (!newSelection.length) {\n      this.selectedOptionsRemoved.push(this.resetAllFiltersLabel)\n    }\n\n    // mark options to show add animation in componentDidUpdate\n    newSelection.forEach((newOption) => {\n      if (!oldSelection.includes(newOption)) {\n        this.selectedOptionsAdded.push(newOption)\n      }\n    })\n  }\n\n  public async componentWillUpdate() {\n    await Promise.all(\n      this.selectedOptionsRemoved.map((option) => {\n        const animationEl = this.chips.get(option)\n        this.chips.delete(option)\n\n        return (\n          animationEl &&\n          animation.scaleOut(animationEl, this.animated ? undefined : 0)\n        )\n      })\n    )\n\n    this.selectedOptionsRemoved = []\n  }\n\n  public async componentDidUpdate() {\n    await Promise.all(\n      this.selectedOptionsAdded.map((option) => {\n        const animationEl = this.chips.get(option)\n\n        return (\n          animationEl &&\n          animation.scaleIn(animationEl, this.animated ? undefined : 0)\n        )\n      })\n    )\n\n    this.selectedOptionsAdded = []\n    this.scrollViewEl?.layout()\n  }\n\n  private createChipEl(label: string) {\n    return (\n      <sdx-button\n        ref={(el) => this.chips.set(label, el!)}\n        key={label}\n        theme=\"chip\"\n        class=\"chip\"\n        label={label}\n        onClick={(e) => {\n          this.sdxdeselectrequest.emit({\n            label: (e.target as HTMLSdxButtonElement).label,\n          })\n        }}\n      />\n    )\n  }\n\n  public render() {\n    return (\n      <div class=\"component row row--gutters\">\n        <div class=\"col\">\n          <slot />\n        </div>\n\n        {this.el.querySelectorAll(\"[slot=filter-more]\").length > 0 && (\n          <div class=\"col\">\n            <sdx-expand-and-collapse\n              arrow-position=\"fixed\"\n              expand-label={this.showMoreLabel}\n              collapse-label={this.showLessLabel}\n            >\n              <slot name=\"filter-more\" />\n            </sdx-expand-and-collapse>\n          </div>\n        )}\n\n        {this.selection.length > 0 && (\n          <div class=\"col\">\n            <sdx-scroll-view ref={(el) => (this.scrollViewEl = el)}>\n              <div class=\"chips-wrapper\">\n                {this.createChipEl(this.resetAllFiltersLabel)}\n                {this.selection.map((option) => this.createChipEl(option))}\n              </div>\n            </sdx-scroll-view>\n          </div>\n        )}\n\n        {this.resultLabel && <div class=\"col\">{this.resultLabel}</div>}\n      </div>\n    )\n  }\n}\n",":host {\n  max-width: 100%;\n}\n\n.component {\n  height: inherit;\n  position: relative; // for arrows\n  overflow-x: hidden;\n\n  &.is-touchscreen {\n    .scrollable {\n      overflow-x: auto;\n\n      // Hide scrollbar on iOS Safari and Android Chrome\n      &::-webkit-scrollbar {\n        display: none;\n      }\n    }\n  }\n\n  .scrollable {\n    height: inherit;\n  }\n\n  sdx-arrow {\n    position: absolute;\n    top: 0;\n    width: 40px;\n\n    &.left {\n      left: 0;\n    }\n\n    &.right {\n      right: 0;\n    }\n  }\n}\n","import { Component, h, State, Prop, Listen, Method } from \"@stencil/core\"\nimport anime from \"animejs\"\nimport { isTouchscreen } from \"../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-scroll-view\",\n  styleUrl: \"scroll-view.scss\",\n  shadow: true,\n})\nexport class ScrollView {\n  private componentEl?: HTMLDivElement\n  private scrollableEl?: HTMLDivElement\n  private slotEl?: HTMLDivElement\n\n  private currentAnimation?: anime.AnimeInstance\n  private resizeTimer?: NodeJS.Timer\n  private scrollingTimer?: NodeJS.Timer\n  private componentDidLoadComplete = false\n\n  @State() private showLeftArrow = false\n  @State() private showRightArrow = false\n\n  /**\n   * Don't show the arrows (not recommended by UX).\n   * @private\n   */\n  @Prop() public arrowsHidden = false\n\n  /**\n   * Disable animations for testing.\n   * @private\n   */\n  @Prop() public animated: boolean = true\n\n  /**\n   * The top position in px of the arrows (needed in sdx-progress-full).\n   * @private\n   */\n  @Prop() public arrowPositionTop?: number\n\n  @Listen(\"resize\", { target: \"window\" })\n  public onWindowResizeDebounced() {\n    if (this.resizeTimer) {\n      clearTimeout(this.resizeTimer)\n    }\n\n    this.resizeTimer = setTimeout(() => {\n      if (!this.scrollableEl) {\n        return\n      }\n\n      this.showArrowsIfNeeded()\n\n      const { clientWidth, scrollWidth } = this.scrollableEl\n      const hasEnoughSpace = clientWidth === scrollWidth\n\n      // When enough space, scroll back to beginning\n      if (hasEnoughSpace) {\n        this.translateX(-this.getOverflow(\"left\"), false)\n      }\n    }, 10)\n  }\n\n  /**\n   * Scrolls till the element is centered in parent.\n   * @param HTMLElement The parent element in which the element should be centered.\n   * @param HTMLElement The element which should be centered.\n   * @param number The gutter.\n   * @param boolean Controls if scrolling is animated or not.\n   * @returns {Promise} Resolved when scroll animation is done.\n   * @private\n   */\n  @Method()\n  public async centerElement(\n    parent: HTMLElement,\n    toBeCentered: HTMLElement | undefined,\n    animated = true\n  ) {\n    if (!parent || !toBeCentered) {\n      return\n    }\n\n    const componentElRect = parent.getBoundingClientRect()\n    const clickableElRect = toBeCentered.getBoundingClientRect()\n    const offsetLeft = componentElRect.left\n    const clickableElLeft = clickableElRect.left - offsetLeft\n\n    const componentElCenter = componentElRect.width / 2\n    const clickableElCenter = clickableElRect.width / 2\n\n    const hasItemElOverflow = {\n      toLeft: componentElRect.left - clickableElRect.left > 0,\n      toRight: clickableElRect.right - componentElRect.right > 0,\n    }\n\n    // Scroll to selected tab when it's out of sight\n    if (hasItemElOverflow.toLeft || hasItemElOverflow.toRight) {\n      this.translateX(\n        clickableElLeft - componentElCenter + clickableElCenter,\n        animated\n      )\n    }\n  }\n\n  /**\n   * Scroll to the left or to the right.\n   * @param number The distance in px. Negative numbers causes left scroll.\n   * @param boolean Controls if scrolling is animated or not.\n   * @returns {Promise} Resolved when scroll animation is done.\n   * @private\n   */\n  @Method()\n  public async translateX(translateX: number, animated = true): Promise<void> {\n    if (!this.currentAnimation?.completed) {\n      await this.currentAnimation?.finished\n    }\n\n    const scrollableEl = this.scrollableEl!\n    const overflowToLeft = this.getOverflow(\"left\")\n    const overflowToRight = this.getOverflow(\"right\")\n\n    if (translateX > 0) {\n      // to right\n      translateX = Math.min(translateX, overflowToRight)\n    } else {\n      // to left\n      translateX = Math.max(translateX, -overflowToLeft)\n    }\n\n    // Animation starts\n    this.currentAnimation = anime({\n      targets: this.scrollableEl,\n      easing: \"easeOutQuad\",\n      duration: animated ? this.getAnimationDuration() : 0,\n      translateX: `-=${translateX}`,\n      complete: () => {\n        this.showArrowsIfNeeded()\n\n        // \"Convert\" translateX into scrollLeft for touchscreens.\n        // Alternatively, instead of animating \"translateX\", it also works to\n        // animate \"scrollLeft\". This would make this converting obsolete.\n        // However, there was a glitch that caused the scrollable element to\n        // jump when hovering over the selected tab after scrolling.\n        if (isTouchscreen()) {\n          // Causes a scroll event\n          scrollableEl.scrollTo(\n            scrollableEl.scrollLeft + translateX,\n            scrollableEl.scrollTop\n          )\n\n          anime.set(scrollableEl, { translateX: 0 })\n        }\n      },\n    })\n\n    return this.currentAnimation.finished\n  }\n\n  /**\n   * Draws the layout. Useful to redraw the component when initially\n   * rendered on a hidden parent (e.g. an sdx-header).\n   */\n  @Method()\n  public async layout() {\n    this.showArrowsIfNeeded()\n  }\n\n  public componentDidLoad() {\n    this.showArrowsIfNeeded()\n\n    this.componentDidLoadComplete = true\n  }\n\n  private getAnimationDuration(): number {\n    if (!this.componentDidLoadComplete) {\n      return 0\n    }\n\n    return this.animated ? 200 : 0\n  }\n\n  private getOverflow(to: \"left\" | \"right\"): number {\n    const componentElRect = this.componentEl!.getBoundingClientRect()\n    const slotElRect = this.slotEl!.getBoundingClientRect()\n    const { scrollWidth } = this.scrollableEl!\n\n    if (to === \"left\") {\n      return componentElRect.left - slotElRect.left\n    } else {\n      // \"right\"\n      return slotElRect.left + scrollWidth - componentElRect.right\n    }\n  }\n\n  // getBoundingClientRect() does return floats, therefore it happens that\n  // an element has an overflow of 0.666px, which is mathematically true, but\n  // in reality does not count as a real overflow. Therefore check for 1\n  // instead (which will be a \"real\" pixel, not a subpixel).\n  private hasOverflow(to: \"left\" | \"right\"): boolean {\n    if (to === \"left\") {\n      return this.getOverflow(\"left\") >= 1\n    } else {\n      // \"right\"\n      return this.getOverflow(\"right\") >= 1\n    }\n  }\n\n  private showArrowsIfNeeded(): void {\n    this.showLeftArrow = this.hasOverflow(\"left\")\n    this.showRightArrow = this.hasOverflow(\"right\")\n  }\n\n  private onScroll(): void {\n    if (this.scrollingTimer) {\n      clearTimeout(this.scrollingTimer)\n    }\n\n    this.scrollingTimer = setTimeout(() => {\n      this.onScrollDebounced()\n    }, 30)\n  }\n\n  // Needed for touch initiated scrolling\n  private onScrollDebounced(): void {\n    this.showArrowsIfNeeded()\n  }\n\n  private onArrowClick(which: \"left\" | \"right\"): void {\n    const componentElRect = this.componentEl!.getBoundingClientRect()\n\n    // Scroll only by half of the available only so that end users don't lose\n    // overview\n    const translateX = componentElRect.width / 2\n\n    this.translateX(which === \"left\" ? -translateX : translateX)\n  }\n\n  private getComponentClassNames() {\n    return {\n      component: true,\n      \"is-touchscreen\": isTouchscreen(),\n    }\n  }\n\n  public render() {\n    return (\n      <div\n        class={this.getComponentClassNames()}\n        ref={(el) => (this.componentEl = el)}\n      >\n        <div\n          class=\"scrollable\"\n          onScroll={() => this.onScroll()}\n          ref={(el) => (this.scrollableEl = el)}\n        >\n          <div class=\"slot\" ref={(el) => (this.slotEl = el)}>\n            <slot />\n          </div>\n        </div>\n\n        <sdx-arrow\n          class=\"left\"\n          direction=\"left\"\n          hidden={!this.showLeftArrow}\n          onClick={() => this.onArrowClick(\"left\")}\n          animationDuration={this.getAnimationDuration()}\n          arrowHidden={this.arrowsHidden}\n          arrowPositionTop={this.arrowPositionTop}\n        />\n\n        <sdx-arrow\n          class=\"right\"\n          direction=\"right\"\n          hidden={!this.showRightArrow}\n          onClick={() => this.onArrowClick(\"right\")}\n          animationDuration={this.getAnimationDuration()}\n          arrowHidden={this.arrowsHidden}\n          arrowPositionTop={this.arrowPositionTop}\n        />\n      </div>\n    )\n  }\n}\n","@import \"stylesheets/sdx/utilities/screenreaders\";\n","/* eslint-disable jsx-a11y/no-noninteractive-tabindex */\nimport {\n  Component,\n  Element,\n  h,\n  Host,\n  Listen,\n  Method,\n  Prop,\n} from \"@stencil/core\"\nimport { closest, translate } from \"../../core/helpers/webcomponent-helpers\"\n\n@Component({\n  tag: \"sdx-trap-focus\",\n  styleUrl: \"trap-focus.scss\",\n  shadow: true,\n})\nexport class TrapFocus {\n  private startOfDialogHiddenEl?: HTMLDivElement\n  private endOfDialogHiddenEl?: HTMLDivElement\n  private slotEl?: HTMLSlotElement\n\n  @Element() public el!: HTMLSdxTrapFocusElement\n\n  /**\n   * This element is focused if the end of focus circuit is reached and tab key\n   * is pressed.\n   * The element could only be a <sdx-button>.\n   */\n  @Prop() public firstFocusableElement?: HTMLSdxButtonElement\n\n  @Listen(\"keyup\") // to avoid that user has to tab two times at the last element (analog at the first element with pressed shift key)\n  @Listen(\"keydown\") // at the last element keyup event is too late (analog at the first element with pressed shift key)\n  public onKey(e: KeyboardEvent) {\n    const isTabPressed = e.key === \"Tab\"\n\n    if (!isTabPressed) {\n      return\n    }\n\n    const { startOfDialogHiddenEl, endOfDialogHiddenEl } = this\n    const hasFocusElement = this.el.shadowRoot?.activeElement\n\n    if (e.shiftKey) {\n      // if shift key pressed for shift + tab combination\n      if (hasFocusElement === startOfDialogHiddenEl) {\n        endOfDialogHiddenEl?.focus()\n        e.preventDefault()\n      }\n    } else {\n      // if only tab key is pressed\n      if (hasFocusElement === endOfDialogHiddenEl) {\n        this.setFocusToFirstElement()\n        e.preventDefault()\n      }\n    }\n  }\n\n  /**\n   * Sets the focus on the component if a child does not have the focus yet.\n   */\n  @Method()\n  public async doFocus() {\n    const { el, slotEl } = this\n\n    const elWithoutSlotContainsActiveElement = el.contains(\n      document.activeElement\n    )\n\n    const slotContainsActiveElement = slotEl\n      ?.assignedElements()\n      .some((value) => closest(document.activeElement, value))\n\n    if (!(slotContainsActiveElement || elWithoutSlotContainsActiveElement)) {\n      this.setFocusToFirstElement()\n    }\n  }\n\n  private setFocusToFirstElement() {\n    const { startOfDialogHiddenEl, firstFocusableElement } = this\n    firstFocusableElement\n      ? firstFocusableElement?.doFocus()\n      : startOfDialogHiddenEl?.focus()\n  }\n\n  public render() {\n    return (\n      <Host>\n        <div\n          class=\"sr-only\"\n          data-nosnippet\n          ref={(el) => (this.startOfDialogHiddenEl = el)}\n          tabindex={0}\n        >\n          {translate(\"Start of dialog\", this.el.lang)}\n        </div>\n\n        <slot ref={(el) => (this.slotEl = el as HTMLSlotElement)} />\n\n        <div\n          class=\"sr-only\"\n          data-nosnippet\n          ref={(el) => (this.endOfDialogHiddenEl = el)}\n          tabindex={0}\n        >\n          {translate(\"End of dialog\", this.el.lang)}\n        </div>\n      </Host>\n    )\n  }\n}\n"],"names":["Backdrop","component","getAppearance","this","el","h","class","getComponentClassNames","ExpandAndCollapse","open","accordion","border","borderRadius","header","fontSize","padding","justifyContent","alignItems","body","margin","arrowPosition","arrow","top","getAccordionStyles","id","onClick","toggle","arrowStyle","buttonStyle","collapseLabel","expandLabel","srHint","componentStyle","createHeader","role","Filter","chips","Map","selectedOptionsRemoved","selectedOptionsAdded","translate","lang","newSelection","oldSelection","forEach","oldOption","includes","push","length","resetAllFiltersLabel","newOption","Promise","all","map","option","animationEl","get","delete","animation","animated","undefined","scrollViewEl","_a","layout","label","ref","set","key","theme","e","sdxdeselectrequest","emit","target","querySelectorAll","showMoreLabel","showLessLabel","name","selection","createChipEl","resultLabel","ScrollView","componentDidLoadComplete","resizeTimer","clearTimeout","setTimeout","scrollableEl","showArrowsIfNeeded","clientWidth","scrollWidth","translateX","getOverflow","parent","toBeCentered","componentElRect","getBoundingClientRect","clickableElRect","offsetLeft","left","clickableElLeft","componentElCenter","width","clickableElCenter","hasItemElOverflow","toLeft","toRight","right","currentAnimation","completed","_b","finished","overflowToLeft","overflowToRight","Math","min","max","anime","targets","easing","duration","getAnimationDuration","complete","isTouchscreen","scrollTo","scrollLeft","scrollTop","to","componentEl","slotElRect","slotEl","showLeftArrow","hasOverflow","showRightArrow","scrollingTimer","onScrollDebounced","which","onScroll","direction","hidden","onArrowClick","animationDuration","arrowHidden","arrowsHidden","arrowPositionTop","TrapFocus","startOfDialogHiddenEl","endOfDialogHiddenEl","hasFocusElement","shadowRoot","activeElement","shiftKey","focus","preventDefault","setFocusToFirstElement","elWithoutSlotContainsActiveElement","contains","document","assignedElements","some","value","closest","firstFocusableElement","doFocus","Host","tabindex"],"sourceRoot":""}