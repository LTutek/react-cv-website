{"version":3,"file":"static/js/327.9ef42596.chunk.js","mappings":"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","sources":["../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/core/helpers/immutability-helpers.ts","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/tabs/tabs-store.ts","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/tabs/tabs.scss?tag=sdx-tabs&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/tabs/tabs.tsx","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/tabs/tabs-item/tabs-item.scss?tag=sdx-tabs-item&encapsulation=shadow","../node_modules/@swisscom/sdx/dist/js/webcomponents/esm/webcomponents/components/tabs/tabs-item/tabs-item.tsx","../node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js"],"sourcesContent":["/**\n * Adds an item to a list, if it does not exist, yet.\n * @param list The array that might contain the given item.\n * @param item The element that should be added.\n */\nexport function add<I>(list: I[], item: I): I[] {\n  if (!list.includes(item)) {\n    return [...list, item]\n  }\n\n  return list\n}\n\n/**\n * Removes an item from a list, if it exists.\n * @param list The array that might contain the given item.\n * @param item The element that should be removed.\n */\nexport function remove<I>(list: I[], item: I): I[] {\n  if (list.includes(item)) {\n    return list.filter((currentItem) => currentItem !== item)\n  }\n\n  return list\n}\n\n/**\n * Adds an item to a list, if it does not exist, yet.\n * If it does exist, however, it removes it.\n * @param list The array that might contain the given item.\n * @param item The element that should be added or removed.\n */\nexport function toggle<I>(list: I[], item: I): I[] {\n  if (!list.includes(item)) {\n    return add(list, item)\n  }\n\n  return remove(list, item)\n}\n\n/**\n * Like Array map() but for objects.\n * Example: { foo: \"bar\" } => { foo1: \"bar1\" }\n * @param obj Object to iterate.\n * @param cb Callback that transforms key and value.\n */\nexport function objectMap(\n  obj: Record<string, unknown> | undefined,\n  cb: (key: string, value: unknown) => Record<string, unknown>\n): Record<string, unknown> {\n  let newObj: Record<string, unknown> = {}\n\n  for (const key in obj) {\n    newObj = { ...newObj, ...cb(key, obj[key]) }\n  }\n\n  return newObj\n}\n","import { Reducer } from \"redux\"\nimport { sortByAppearanceInDomTree } from \"../../core/helpers/webcomponent-helpers\"\nimport { add, remove } from \"../../core/helpers/immutability-helpers\"\n\nexport interface TabsState {\n  tabsItemEls: HTMLSdxTabsItemElement[]\n  selectedTabsItemEl?: HTMLSdxTabsItemElement\n  userInteractionInProgress: boolean\n}\n\nexport type TabsActions =\n  | { type: \"ADD_TABS_ITEM_EL\"; tabsItemEl: HTMLSdxTabsItemElement }\n  | { type: \"REMOVE_TABS_ITEM_EL\"; tabsItemEl: HTMLSdxTabsItemElement }\n  | { type: \"DESELECT_TABS_ITEM_EL\"; tabsItemEl: HTMLSdxTabsItemElement }\n  | { type: \"RESET_TABS_ITEM_ELS\" }\n\nexport const tabsReducer: Reducer<TabsState, TabsActions> = (\n  state = {} as TabsState,\n  action\n): TabsState => {\n  switch (action.type) {\n    case \"ADD_TABS_ITEM_EL\":\n      return {\n        ...state,\n        tabsItemEls: add(state.tabsItemEls, action.tabsItemEl).sort(\n          sortByAppearanceInDomTree\n        ),\n      }\n\n    case \"REMOVE_TABS_ITEM_EL\":\n      return {\n        ...state,\n        tabsItemEls: remove(state.tabsItemEls, action.tabsItemEl).sort(\n          sortByAppearanceInDomTree\n        ),\n      }\n\n    case \"DESELECT_TABS_ITEM_EL\":\n      if (state.selectedTabsItemEl === action.tabsItemEl) {\n        return { ...state, selectedTabsItemEl: undefined }\n      }\n\n      return state\n\n    case \"RESET_TABS_ITEM_ELS\":\n      // Simply trigger change detection\n      return { ...state, tabsItemEls: [...state.tabsItemEls] }\n\n    default:\n      return state\n  }\n}\n\nexport function getInitialState(): TabsState {\n  return {\n    tabsItemEls: [],\n    selectedTabsItemEl: undefined,\n    userInteractionInProgress: false,\n  }\n}\n","@import \"../../globals/scss/button\";\n\n:host {\n  display: block;\n}\n\n.component {\n  display: flex;\n  flex-flow: column;\n\n  &.centered {\n    .header {\n      align-self: center;\n    }\n  }\n\n  &.left-aligned {\n    .header {\n      align-self: flex-start;\n    }\n  }\n\n  .header {\n    background: $color-horizon;\n    border-radius: $border-radius-large;\n    max-width: 100%;\n    align-self: flex-start;\n\n    .tablist {\n      position: relative; // for .indicator positioning\n      list-style-type: none;\n      margin: 0;\n      white-space: nowrap;\n\n      .indicator {\n        position: absolute;\n        width: $tabs-min-width;\n        top: 0;\n        bottom: 0;\n        background-color: $color-navy;\n        border-radius: $border-radius-large;\n\n        @include bp-md {\n          width: $tabs-min-width-lg;\n        }\n      }\n\n      .clickable {\n        cursor: pointer;\n        min-width: $tabs-min-width;\n        max-width: $tabs-max-width;\n        padding: 12px $baseline-3;\n        position: relative; // to be above .indicator\n\n        @include bp-md {\n          padding: 12px $baseline-6;\n          min-width: $tabs-min-width-lg;\n          max-width: $tabs-max-width-lg;\n        }\n\n        &:is(a) {\n          display: inline-block;\n        }\n\n        &:hover {\n          color: $color-int-blue--active;\n        }\n\n        &:disabled {\n          @include disabled;\n          color: rgba($color-gray, 0.4);\n        }\n\n        &.selected {\n          color: $color-white;\n        }\n      }\n    }\n  }\n\n  .body {\n    padding: $baseline-3 0 0;\n  }\n}\n\n.component.sdx--dark-theme {\n  .header {\n    background: $color-dusk-tint-4-dark-theme;\n\n    .tablist {\n      .indicator {\n        background-color: rgba($color-int-gray-dark-theme, 0.15);\n      }\n\n      .clickable {\n        &:hover {\n          color: $color-int-blue2-dark-theme--active;\n        }\n\n        &:disabled {\n          color: rgba($color-gray-dark-theme, 0.5);\n        }\n\n        &.selected {\n          color: $color-int-blue2-dark-theme;\n        }\n      }\n    }\n  }\n}\n","import {\n  Component,\n  h,\n  Element,\n  State,\n  Watch,\n  Event,\n  EventEmitter,\n  Listen,\n  Prop,\n  Method,\n} from \"@stencil/core\"\nimport {\n  parseFunction,\n  getPreviousFromList,\n  getNextFromList,\n  isHidden,\n  getAppearance,\n  StoreConnection,\n  StateHandle,\n  waitFor,\n  animation,\n} from \"../../core/helpers/webcomponent-helpers\"\nimport {\n  tabsReducer,\n  getInitialState,\n  TabsState,\n  TabsActions,\n} from \"./tabs-store\"\n\n@Component({\n  tag: \"sdx-tabs\",\n  styleUrl: \"tabs.scss\",\n  shadow: true,\n})\nexport class Tabs {\n  private store: StoreConnection<this, TabsState, TabsActions>\n  private componentEl?: HTMLDivElement\n  private sdxScrollViewEl?: HTMLSdxScrollViewElement\n  private indicatorEl?: HTMLDivElement\n  private tablistEl?: HTMLDivElement\n  private isInitialLayout = true\n  private componentDidLoadComplete = false\n  private invokeChangeCallback: Function = () => null\n  private selectedTabsItemElDidUpdate = false\n  private tabsItemElsDidUpdate = false\n  private resizeTimer?: NodeJS.Timer\n\n  private tabsItemsWithClickableEl!: WeakMap<\n    HTMLSdxTabsItemElement,\n    HTMLButtonElement | HTMLAnchorElement\n  >\n\n  @Element() public el!: HTMLSdxTabsElement\n\n  @State() public state!: StateHandle<TabsState>\n\n  /**\n   * Callback that will fire when the active tab has changed.\n   * Provides the active tab DOM node.\n   * @deprecated use sdxselect event instead.\n   */\n  @Prop() public changeCallback?: ((activeTab: Node) => void) | string\n\n  /**\n   * Description text read by the screen reader.\n   */\n  @Prop() public srHint: string = \"\"\n\n  /**\n   * Disable animations for testing.\n   * @private\n   */\n  @Prop() public animated: boolean = true\n\n  /**\n   * Arranges the tabs appearance to be either left-aligned (default) or centralised.\n   */\n  @Prop() public theme: \"left-aligned\" | \"centered\" = \"left-aligned\"\n\n  @Watch(\"state\")\n  public stateChanged({}, prev: StateHandle<TabsState>) {\n    const state = this.state.get()\n    const prevState = prev.get()\n\n    if (state.selectedTabsItemEl !== prevState.selectedTabsItemEl) {\n      this.selectedTabsItemElChanged(state)\n    }\n\n    if (state.tabsItemEls !== prevState.tabsItemEls) {\n      this.tabsItemElsChanged()\n    }\n  }\n\n  @Watch(\"changeCallback\")\n  public changeCallbackChanged() {\n    this.setInvokeChangeCallback()\n  }\n\n  /**\n   * Emitted when an item becomes visible.\n   */\n  @Event() public sdxselect!: EventEmitter\n\n  @Listen(\"keydown\", { target: \"window\" })\n  public onKeyDown(e: KeyboardEvent) {\n    // Only react to key events if the component is focussed\n    if (e.target !== this.el) {\n      return\n    }\n\n    const { tabsItemEls, selectedTabsItemEl } = this.state.get()\n    let count = 0\n\n    switch (e.key) {\n      case \"ArrowLeft\": {\n        e.preventDefault() // Prevent scrolling\n\n        let prevEl = getPreviousFromList(tabsItemEls, selectedTabsItemEl)\n\n        if (prevEl) {\n          while (prevEl.disabled && count < tabsItemEls.length) {\n            prevEl = getPreviousFromList(tabsItemEls, prevEl)\n            count += 1\n          }\n\n          this.select(prevEl, true, true)\n        }\n\n        break\n      }\n\n      case \"ArrowRight\": {\n        e.preventDefault() // Prevent scrolling\n\n        let nextEl = getNextFromList(tabsItemEls, selectedTabsItemEl)\n\n        if (nextEl) {\n          while (nextEl.disabled && count < tabsItemEls.length) {\n            nextEl = getNextFromList(tabsItemEls, nextEl)\n            count += 1\n          }\n\n          this.select(nextEl, true, true)\n        }\n\n        break\n      }\n\n      default:\n        break\n    }\n  }\n\n  /**\n   * Draws the layout. Useful to redraw the component when initially\n   * rendered on a hidden parent (e.g. an sdx-tabs-item).\n   */\n  @Method()\n  public async layout() {\n    if (!isHidden(this.el)) {\n      this.sdxScrollViewEl?.layout()\n      this.animateIndicatorElToSelectedTab()\n      this.isInitialLayout = false\n    }\n  }\n\n  @Listen(\"resize\", { target: \"window\" })\n  public onWindowResize() {\n    clearTimeout(this.resizeTimer)\n    this.resizeTimer = setTimeout(\n      () => this.animateIndicatorElToSelectedTab(0),\n      200\n    )\n  }\n\n  constructor() {\n    this.setInvokeChangeCallback()\n\n    this.store = new StoreConnection(this, tabsReducer, getInitialState(), [\n      \"tabsItemEls\",\n      \"selectedTabsItemEl\",\n    ])\n\n    this.store.flush()\n  }\n\n  /**\n   * Delay the first render() until the first item has registered itself.\n   * Otherwise, if sdx-tabs-item.entry.js wasn't fetched fast enough, the\n   * initial render() happens too early (see below) and therefore calls\n   * componentOnReady() too early.\n   *\n   * sdx-tabs: constructor()\n   * sdx-tabs: render() <-- too early, couldn't render buttons yet\n   * sdx-tabs-item: constructor()\n   * sdx-tabs: componentDidLoad()\n   *\n   * Note: it was also tried to move this logic into componentDidRender(),\n   * which is always called *after* all childrens componentDidLoad(), but it\n   * didn't work because in componentDidLoad(), the bounding rect was still 0.\n   *\n   * Also created https://github.com/ionic-team/stencil/issues/3411.\n   */\n  public async componentWillLoad() {\n    await waitFor(() => this.state.get().tabsItemEls.length > 0)\n\n    this.selectDefaultTabsItem()\n  }\n\n  public componentDidLoad() {\n    this.layout()\n\n    this.store.subscribe()\n\n    this.componentDidLoadComplete = true\n  }\n\n  public componentDidUpdate() {\n    if (this.selectedTabsItemElDidUpdate) {\n      this.invokeChangeCallback(this.state.get().selectedTabsItemEl)\n      this.layout()\n\n      this.selectedTabsItemElDidUpdate = false\n    }\n\n    if (this.tabsItemElsDidUpdate) {\n      this.layout()\n\n      this.tabsItemElsDidUpdate = false\n    }\n  }\n\n  private selectedTabsItemElChanged(state: TabsState) {\n    if (!this.componentDidLoadComplete) {\n      return\n    }\n\n    // Ensure visibility of selected tabs item el (if any)\n    if (!state.selectedTabsItemEl) {\n      return\n    }\n\n    this.selectedTabsItemElDidUpdate = true\n  }\n\n  private tabsItemElsChanged() {\n    this.tabsItemElsDidUpdate = true\n  }\n\n  private setInvokeChangeCallback(): void {\n    this.invokeChangeCallback = parseFunction(this.changeCallback)\n  }\n\n  private getAnimationDuration(): number {\n    if (!this.animated) {\n      return 0\n    }\n\n    return this.isInitialLayout ? 0 : 200\n  }\n\n  /**\n   * If no tabs item is selected initially, display the first one\n   */\n  private selectDefaultTabsItem(): void {\n    const { selectedTabsItemEl, tabsItemEls } = this.state.get()\n\n    if (!selectedTabsItemEl) {\n      const defaultTabsItemEl = tabsItemEls.find((el) => !el.disabled)\n\n      defaultTabsItemEl && this.select(defaultTabsItemEl)\n    }\n  }\n\n  private animateIndicatorElToSelectedTab(\n    animationDuration: number = this.getAnimationDuration()\n  ) {\n    const { tabsItemEls, selectedTabsItemEl } = this.state.get()\n\n    if (!selectedTabsItemEl) {\n      this.indicatorEl!.style.display = \"none\"\n\n      return\n    }\n\n    const firstClickableEl = this.tabsItemsWithClickableEl.get(tabsItemEls[0])!\n    const selectedClickableEl =\n      this.tabsItemsWithClickableEl.get(selectedTabsItemEl)!\n\n    const tablistElRect = this.tablistEl!.getBoundingClientRect()\n    const firstClickableElRect = firstClickableEl.getBoundingClientRect()\n    const selectedClickableElRect = selectedClickableEl.getBoundingClientRect()\n\n    const scrollLeft = tablistElRect.left - firstClickableElRect.left\n\n    this.indicatorEl!.style.display = this.isInitialLayout ? \"none\" : \"\"\n\n    this.sdxScrollViewEl!.centerElement(\n      this.componentEl!,\n      selectedClickableEl,\n      !this.isInitialLayout\n    )\n\n    animation.start({\n      targets: this.indicatorEl,\n      duration: animationDuration,\n      easing: \"easeOutQuad\",\n      translateX:\n        selectedClickableElRect.left - tablistElRect.left - scrollLeft,\n      width: selectedClickableElRect.right - selectedClickableElRect.left,\n      complete: () => {\n        this.indicatorEl!.style.display = \"\"\n      },\n    })\n  }\n\n  private select(\n    el: HTMLSdxTabsItemElement,\n    userInteractionInProgress = false,\n    selectedByArrowKeys = false\n  ) {\n    this.store.set(\"userInteractionInProgress\", userInteractionInProgress)\n    this.store.set(\"selectedTabsItemEl\", el)\n    this.store.set(\"userInteractionInProgress\", false)\n\n    // If selected using the keyboard, ensure screen readers detect the change\n    if (selectedByArrowKeys) {\n      this.tabsItemsWithClickableEl.get(el)?.focus()\n    }\n  }\n\n  private getComponentClassNames() {\n    return {\n      component: true,\n      [getAppearance(this.el)]: true,\n      [this.theme]: true,\n    }\n  }\n\n  private getClickableElClassNames(tabsItemEl: HTMLSdxTabsItemElement) {\n    return {\n      clickable: true,\n      \"button-reset\": true,\n      selected: tabsItemEl === this.state.get().selectedTabsItemEl,\n    }\n  }\n\n  public render() {\n    const { tabsItemEls, selectedTabsItemEl } = this.state.get()\n    this.tabsItemsWithClickableEl = new WeakMap() // clear previous entries\n\n    return (\n      <div\n        class={this.getComponentClassNames()}\n        ref={(el) => (this.componentEl = el)}\n      >\n        <div class=\"header\">\n          <sdx-scroll-view ref={(el) => (this.sdxScrollViewEl = el)}>\n            <div\n              class=\"tablist\"\n              role=\"tablist\"\n              aria-label={this.srHint}\n              ref={(el) => (this.tablistEl = el)}\n            >\n              <div\n                class=\"indicator\"\n                ref={(el) => (this.indicatorEl = el)}\n                style={{\n                  display: \"none\" /* will be displayed during animation */,\n                }}\n              />\n\n              {tabsItemEls.map((tabsItemEl) => {\n                const isSelected = tabsItemEl === selectedTabsItemEl\n                const Tag = tabsItemEl.href ? \"a\" : \"button\"\n\n                return (\n                  <Tag\n                    class={this.getClickableElClassNames(tabsItemEl)}\n                    onClick={() => this.select(tabsItemEl, true)}\n                    disabled={tabsItemEl.disabled && !tabsItemEl.href}\n                    aria-disabled={tabsItemEl.disabled.toString()}\n                    aria-selected={isSelected.toString()}\n                    role=\"tab\"\n                    tabindex={isSelected ? \"0\" : \"-1\"}\n                    href={tabsItemEl.href}\n                    ref={(el) =>\n                      el && this.tabsItemsWithClickableEl?.set(tabsItemEl, el)\n                    }\n                  >\n                    <sdx-text-truncate>\n                      <sdx-icon iconName={tabsItemEl.iconName} />{\" \"}\n                      {tabsItemEl.label}\n                    </sdx-text-truncate>\n                  </Tag>\n                )\n              })}\n            </div>\n          </sdx-scroll-view>\n        </div>\n\n        <div class=\"body\">\n          <slot />\n        </div>\n      </div>\n    )\n  }\n}\n",":host {\n  outline: none; // for focus through tabindex\n}\n\n.component {\n  display: none;\n\n  &.selected {\n    display: block;\n  }\n}\n","import {\n  Component,\n  h,\n  Element,\n  State,\n  Prop,\n  Watch,\n  Event,\n  EventEmitter,\n  Host,\n} from \"@stencil/core\"\nimport {\n  StoreConnection,\n  isSDXWebComponent,\n  parseFunction,\n  StateHandle,\n} from \"../../../core/helpers/webcomponent-helpers\"\nimport { IconName } from \"../../../core/types/icon-names\"\nimport {\n  tabsReducer,\n  getInitialState,\n  TabsState,\n  TabsActions,\n} from \"../tabs-store\"\n\n@Component({\n  tag: \"sdx-tabs-item\",\n  styleUrl: \"tabs-item.scss\",\n  shadow: true,\n})\nexport class TabsItem {\n  private store: StoreConnection<this, TabsState, TabsActions>\n  private selectedChangedInProgress = false\n  private invokeSelectedCallback: Function = () => null\n  private onComponentDidUpdate: Function[] = []\n\n  @Element() public el!: HTMLSdxTabsItemElement\n\n  @State() public state!: StateHandle<TabsState>\n\n  /**\n   * Callback that will fire when the tabs item has become visible.\n   * Also fires when opened by default.\n   * @deprecated use sdxselect event instead.\n   */\n  @Prop() public selectedCallback?: (() => void) | string\n\n  /**\n   * Title of the tab.\n   */\n  @Prop() public label: string = \"\"\n\n  /**\n   * The tab is not selectable.\n   */\n  @Prop() public disabled: boolean = false\n\n  /**\n   * Which icon to display.\n   */\n  @Prop() public iconName?: IconName\n\n  /**\n   * The tab is active.\n   */\n  @Prop({ mutable: true }) public selected: boolean = false\n\n  /**\n   * Renders anchor element instead of a button. Can be useful for deep linking, SEO, etc.\n   */\n  @Prop() public href?: string\n\n  @Watch(\"state\")\n  public stateChanged({}, prev: StateHandle<TabsState>) {\n    const state = this.state.get()\n    const prevState = prev.get()\n\n    if (state.selectedTabsItemEl !== prevState.selectedTabsItemEl) {\n      this.selectedTabsItemElChanged(state)\n    }\n  }\n\n  @Watch(\"selectedCallback\")\n  public selectedCallbackChanged() {\n    this.setInvokeSelectedCallback()\n  }\n\n  @Watch(\"selected\")\n  public selectedChanged() {\n    this.selectedChangedInProgress = true\n\n    if (this.selected) {\n      this.store.set(\"selectedTabsItemEl\", this.el)\n    }\n\n    this.selectedChangedInProgress = false\n  }\n\n  @Watch(\"label\")\n  @Watch(\"disabled\")\n  @Watch(\"iconName\")\n  @Watch(\"href\")\n  public propChanged() {\n    this.store.dispatch({ type: \"RESET_TABS_ITEM_ELS\" })\n  }\n\n  /**\n   * Emitted when the item becomes visible.\n   */\n  @Event() public sdxselect!: EventEmitter\n\n  constructor() {\n    this.setInvokeSelectedCallback()\n\n    this.store = new StoreConnection(this, tabsReducer, getInitialState(), [\n      \"selectedTabsItemEl\",\n    ])\n  }\n\n  public connectedCallback() {\n    // Register self\n    this.store.dispatch({\n      type: \"ADD_TABS_ITEM_EL\",\n      tabsItemEl: this.el,\n    })\n\n    if (this.selected) {\n      this.store.set(\"selectedTabsItemEl\", this.el)\n    }\n  }\n\n  public disconnectedCallback() {\n    this.store.dispatch({ type: \"DESELECT_TABS_ITEM_EL\", tabsItemEl: this.el })\n\n    this.store.dispatch({\n      type: \"REMOVE_TABS_ITEM_EL\",\n      tabsItemEl: this.el,\n    })\n  }\n\n  public componentDidLoad() {\n    this.store.subscribe()\n  }\n\n  public componentDidUpdate() {\n    this.onComponentDidUpdate.forEach((fn) => fn())\n    this.onComponentDidUpdate = []\n  }\n\n  private selectedTabsItemElChanged(state: TabsState) {\n    if (!this.selectedChangedInProgress) {\n      this.selected = state.selectedTabsItemEl === this.el\n    }\n\n    // Make sure events are fired *after* the layout has rendered.\n    this.onComponentDidUpdate.push(() => {\n      if (this.selected) {\n        this.layout()\n\n        if (state.userInteractionInProgress) {\n          this.sdxselect.emit()\n        }\n\n        this.invokeSelectedCallback(state.selectedTabsItemEl)\n      }\n    })\n  }\n\n  private setInvokeSelectedCallback(): void {\n    this.invokeSelectedCallback = parseFunction(this.selectedCallback)\n  }\n\n  // Run layout() on all SDX web components on the tab.\n  private layout() {\n    const children = this.el.querySelectorAll(\"*\")\n\n    children.forEach((child: Element & { layout?: Function }) => {\n      if (isSDXWebComponent(child) && typeof child.layout === \"function\") {\n        child.layout()\n      }\n    })\n  }\n\n  private getComponentClassNames() {\n    return {\n      component: true,\n      selected: this.el === this.state.get().selectedTabsItemEl,\n      disabled: this.disabled,\n    }\n  }\n\n  public render() {\n    return (\n      <Host\n        role=\"tabpanel\"\n        aria-label={this.label}\n        tabindex={this.selected ? \"0\" : \"-1\"}\n      >\n        <div class={this.getComponentClassNames()}>\n          <slot />\n        </div>\n      </Host>\n    )\n  }\n}\n","export default function _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}"],"names":["add","list","item","includes","remove","filter","currentItem","toggle","objectMap","obj","cb","newObj","key","tabsReducer","state","action","type","tabsItemEls","tabsItemEl","sort","sortByAppearanceInDomTree","selectedTabsItemEl","undefined","Tabs","isInitialLayout","componentDidLoadComplete","invokeChangeCallback","selectedTabsItemElDidUpdate","tabsItemElsDidUpdate","this","setInvokeChangeCallback","store","StoreConnection","userInteractionInProgress","flush","prev","get","prevState","selectedTabsItemElChanged","tabsItemElsChanged","e","target","el","count","preventDefault","prevEl","getPreviousFromList","disabled","length","select","nextEl","getNextFromList","isHidden","sdxScrollViewEl","_a","layout","animateIndicatorElToSelectedTab","clearTimeout","resizeTimer","setTimeout","waitFor","selectDefaultTabsItem","subscribe","parseFunction","changeCallback","animated","defaultTabsItemEl","find","animationDuration","getAnimationDuration","firstClickableEl","tabsItemsWithClickableEl","selectedClickableEl","tablistElRect","tablistEl","getBoundingClientRect","firstClickableElRect","selectedClickableElRect","scrollLeft","left","indicatorEl","style","display","centerElement","componentEl","animation","targets","duration","easing","translateX","width","right","complete","selectedByArrowKeys","set","focus","component","getAppearance","theme","clickable","selected","WeakMap","h","class","getComponentClassNames","ref","role","srHint","map","isSelected","Tag","href","getClickableElClassNames","onClick","toString","tabindex","iconName","label","TabsItem","selectedChangedInProgress","invokeSelectedCallback","onComponentDidUpdate","setInvokeSelectedCallback","dispatch","forEach","fn","push","sdxselect","emit","selectedCallback","querySelectorAll","child","isSDXWebComponent","Host","_objectDestructuringEmpty","TypeError"],"sourceRoot":""}